var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import set from 'lodash.set';
import unset from 'lodash.unset';
import cloneDeep from 'lodash.clonedeep';
import { genRequestId } from './message';
import { RealtimeListener } from './listener';
import { Snapshot } from './snapshot';
import { ERR_CODE, CloudSDKError, isTimeoutError, CancelledError, isCancelledError, isRealtimeErrorMessageError, } from './error';
import { sleep } from './utils';
var WATCH_STATUS;
(function (WATCH_STATUS) {
    WATCH_STATUS["LOGGINGIN"] = "LOGGINGIN";
    WATCH_STATUS["INITING"] = "INITING";
    WATCH_STATUS["REBUILDING"] = "REBUILDING";
    WATCH_STATUS["ACTIVE"] = "ACTIVE";
    WATCH_STATUS["ERRORED"] = "ERRORED";
    WATCH_STATUS["CLOSING"] = "CLOSING";
    WATCH_STATUS["CLOSED"] = "CLOSED";
    WATCH_STATUS["PAUSED"] = "PAUSED";
    WATCH_STATUS["RESUMING"] = "RESUMING";
})(WATCH_STATUS || (WATCH_STATUS = {}));
var DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR = 100;
var DEFAULT_MAX_AUTO_RETRY_ON_ERROR = 2;
var DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR = 2;
var DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT = 10 * 1000;
var DEFAULT_INIT_WATCH_TIMEOUT = 10 * 1000;
var DEFAULT_REBUILD_WATCH_TIMEOUT = 10 * 1000;
var VirtualWebSocketClient = (function () {
    function VirtualWebSocketClient(options) {
        var _this = this;
        this.watchStatus = WATCH_STATUS.INITING;
        this._login = function (envId, refresh) { return __awaiter(_this, void 0, void 0, function () {
            var loginResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.watchStatus = WATCH_STATUS.LOGGINGIN;
                        return [4, this.login(envId, refresh)];
                    case 1:
                        loginResult = _a.sent();
                        if (!this.envId) {
                            this.envId = loginResult.envId;
                        }
                        return [2, loginResult];
                }
            });
        }); };
        this.initWatch = function (forceRefreshLogin) { return __awaiter(_this, void 0, void 0, function () {
            var success;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._initWatchPromise) {
                            return [2, this._initWatchPromise];
                        }
                        this._initWatchPromise = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                            var envId, initWatchMsg, initEventMsg, _a, events, currEvent, _i, events_1, e, snapshot, e_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 3, , 4]);
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] initWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        return [4, this._login(this.envId, forceRefreshLogin)];
                                    case 1:
                                        envId = (_b.sent()).envId;
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] initWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        this.watchStatus = WATCH_STATUS.INITING;
                                        initWatchMsg = {
                                            watchId: this.watchId,
                                            requestId: genRequestId(),
                                            msgType: 'INIT_WATCH',
                                            msgData: {
                                                envId: envId,
                                                collName: this.collectionName,
                                                query: this.query,
                                                limit: this.limit,
                                                orderBy: this.orderBy,
                                            },
                                        };
                                        return [4, this.send({
                                                msg: initWatchMsg,
                                                waitResponse: true,
                                                skipOnMessage: true,
                                                timeout: DEFAULT_INIT_WATCH_TIMEOUT,
                                            })];
                                    case 2:
                                        initEventMsg = _b.sent();
                                        _a = initEventMsg.msgData, events = _a.events, currEvent = _a.currEvent;
                                        this.sessionInfo = {
                                            queryID: initEventMsg.msgData.queryID,
                                            currentEventId: currEvent - 1,
                                            currentDocs: [],
                                        };
                                        if (events.length > 0) {
                                            for (_i = 0, events_1 = events; _i < events_1.length; _i++) {
                                                e = events_1[_i];
                                                e.ID = currEvent;
                                            }
                                            this.handleServerEvents(initEventMsg);
                                        }
                                        else {
                                            this.sessionInfo.currentEventId = currEvent;
                                            snapshot = new Snapshot({
                                                id: currEvent,
                                                docChanges: [],
                                                docs: [],
                                                type: 'init',
                                            });
                                            this.listener.onChange(snapshot);
                                            this.scheduleSendACK();
                                        }
                                        this.onWatchStart(this, this.sessionInfo.queryID);
                                        this.watchStatus = WATCH_STATUS.ACTIVE;
                                        this._availableRetries.INIT_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
                                        resolve();
                                        return [3, 4];
                                    case 3:
                                        e_1 = _b.sent();
                                        this.handleWatchEstablishmentError(e_1, {
                                            operationName: 'INIT_WATCH',
                                            resolve: resolve,
                                            reject: reject,
                                        });
                                        return [3, 4];
                                    case 4: return [2];
                                }
                            });
                        }); });
                        success = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4, this._initWatchPromise];
                    case 2:
                        _a.sent();
                        success = true;
                        return [3, 4];
                    case 3:
                        this._initWatchPromise = undefined;
                        return [7];
                    case 4:
                        console.log("[realtime] initWatch ".concat(success ? 'success' : 'fail'));
                        return [2];
                }
            });
        }); };
        this.rebuildWatch = function (forceRefreshLogin) { return __awaiter(_this, void 0, void 0, function () {
            var success;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._rebuildWatchPromise) {
                            return [2, this._rebuildWatchPromise];
                        }
                        this._rebuildWatchPromise = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                            var envId, rebuildWatchMsg, nextEventMsg, e_2;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 3, , 4]);
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] rebuildWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        return [4, this._login(this.envId, forceRefreshLogin)];
                                    case 1:
                                        envId = (_a.sent()).envId;
                                        if (!this.sessionInfo) {
                                            throw new Error('can not rebuildWatch without a successful initWatch (lack of sessionInfo)');
                                        }
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] rebuildWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        this.watchStatus = WATCH_STATUS.REBUILDING;
                                        rebuildWatchMsg = {
                                            watchId: this.watchId,
                                            requestId: genRequestId(),
                                            msgType: 'REBUILD_WATCH',
                                            msgData: {
                                                envId: envId,
                                                collName: this.collectionName,
                                                queryID: this.sessionInfo.queryID,
                                                eventID: this.sessionInfo.currentEventId,
                                            },
                                        };
                                        return [4, this.send({
                                                msg: rebuildWatchMsg,
                                                waitResponse: true,
                                                skipOnMessage: false,
                                                timeout: DEFAULT_REBUILD_WATCH_TIMEOUT,
                                            })];
                                    case 2:
                                        nextEventMsg = _a.sent();
                                        this.handleServerEvents(nextEventMsg);
                                        this.watchStatus = WATCH_STATUS.ACTIVE;
                                        this._availableRetries.REBUILD_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
                                        resolve();
                                        return [3, 4];
                                    case 3:
                                        e_2 = _a.sent();
                                        this.handleWatchEstablishmentError(e_2, {
                                            operationName: 'REBUILD_WATCH',
                                            resolve: resolve,
                                            reject: reject,
                                        });
                                        return [3, 4];
                                    case 4: return [2];
                                }
                            });
                        }); });
                        success = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4, this._rebuildWatchPromise];
                    case 2:
                        _a.sent();
                        success = true;
                        return [3, 4];
                    case 3:
                        this._rebuildWatchPromise = undefined;
                        return [7];
                    case 4:
                        console.log("[realtime] rebuildWatch ".concat(success ? 'success' : 'fail'));
                        return [2];
                }
            });
        }); };
        this.handleWatchEstablishmentError = function (e, options) { return __awaiter(_this, void 0, void 0, function () {
            var isInitWatch, abortWatch, retry;
            var _this = this;
            return __generator(this, function (_a) {
                isInitWatch = options.operationName === 'INIT_WATCH';
                abortWatch = function () {
                    _this.closeWithError(new CloudSDKError({
                        errCode: isInitWatch
                            ? ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL
                            : ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL,
                        errMsg: e,
                    }));
                    options.reject(e);
                };
                retry = function (refreshLogin) {
                    if (_this.useRetryTicket(options.operationName)) {
                        if (isInitWatch) {
                            _this._initWatchPromise = undefined;
                            options.resolve(_this.initWatch(refreshLogin));
                        }
                        else {
                            _this._rebuildWatchPromise = undefined;
                            options.resolve(_this.rebuildWatch(refreshLogin));
                        }
                    }
                    else {
                        abortWatch();
                    }
                };
                this.handleCommonError(e, {
                    onSignError: function () { return retry(true); },
                    onTimeoutError: function () { return retry(false); },
                    onNotRetryableError: abortWatch,
                    onCancelledError: options.reject,
                    onUnknownError: function () { return __awaiter(_this, void 0, void 0, function () {
                        var onWSDisconnected, e_3;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 8, , 9]);
                                    onWSDisconnected = function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    this.pause();
                                                    return [4, this.onceWSConnected()];
                                                case 1:
                                                    _a.sent();
                                                    retry(true);
                                                    return [2];
                                            }
                                        });
                                    }); };
                                    if (!!this.isWSConnected()) return [3, 2];
                                    return [4, onWSDisconnected()];
                                case 1:
                                    _a.sent();
                                    return [3, 7];
                                case 2: return [4, sleep(DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR)];
                                case 3:
                                    _a.sent();
                                    if (!(this.watchStatus === WATCH_STATUS.PAUSED)) return [3, 4];
                                    options.reject(new CancelledError("".concat(options.operationName, " cancelled due to pause after unknownError")));
                                    return [3, 7];
                                case 4:
                                    if (!!this.isWSConnected()) return [3, 6];
                                    return [4, onWSDisconnected()];
                                case 5:
                                    _a.sent();
                                    return [3, 7];
                                case 6:
                                    retry(false);
                                    _a.label = 7;
                                case 7: return [3, 9];
                                case 8:
                                    e_3 = _a.sent();
                                    retry(true);
                                    return [3, 9];
                                case 9: return [2];
                            }
                        });
                    }); },
                });
                return [2];
            });
        }); };
        this.closeWatch = function () { return __awaiter(_this, void 0, void 0, function () {
            var queryId, closeWatchMsg, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        queryId = this.sessionInfo ? this.sessionInfo.queryID : '';
                        if (this.watchStatus !== WATCH_STATUS.ACTIVE) {
                            this.watchStatus = WATCH_STATUS.CLOSED;
                            this.onWatchClose(this, queryId);
                            return [2];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, 4, 5]);
                        this.watchStatus = WATCH_STATUS.CLOSING;
                        closeWatchMsg = {
                            watchId: this.watchId,
                            requestId: genRequestId(),
                            msgType: 'CLOSE_WATCH',
                            msgData: null,
                        };
                        return [4, this.send({
                                msg: closeWatchMsg,
                            })];
                    case 2:
                        _a.sent();
                        this.sessionInfo = undefined;
                        this.watchStatus = WATCH_STATUS.CLOSED;
                        return [3, 5];
                    case 3:
                        e_4 = _a.sent();
                        this.closeWithError(new CloudSDKError({
                            errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL,
                            errMsg: e_4,
                        }));
                        return [3, 5];
                    case 4:
                        this.onWatchClose(this, queryId);
                        return [7];
                    case 5: return [2];
                }
            });
        }); };
        this.scheduleSendACK = function () {
            _this.clearACKSchedule();
            _this._ackTimeoutId = setTimeout(function () {
                if (_this._waitExpectedTimeoutId) {
                    _this.scheduleSendACK();
                }
                else {
                    _this.sendACK();
                }
            }, DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT);
        };
        this.clearACKSchedule = function () {
            if (_this._ackTimeoutId) {
                clearTimeout(_this._ackTimeoutId);
            }
        };
        this.sendACK = function () { return __awaiter(_this, void 0, void 0, function () {
            var ackMsg, e_5, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        if (this.watchStatus !== WATCH_STATUS.ACTIVE) {
                            this.scheduleSendACK();
                            return [2];
                        }
                        if (!this.sessionInfo) {
                            console.warn('[realtime listener] can not send ack without a successful initWatch (lack of sessionInfo)');
                            return [2];
                        }
                        ackMsg = {
                            watchId: this.watchId,
                            requestId: genRequestId(),
                            msgType: 'CHECK_LAST',
                            msgData: {
                                queryID: this.sessionInfo.queryID,
                                eventID: this.sessionInfo.currentEventId,
                            },
                        };
                        return [4, this.send({
                                msg: ackMsg,
                            })];
                    case 1:
                        _a.sent();
                        this.scheduleSendACK();
                        return [3, 3];
                    case 2:
                        e_5 = _a.sent();
                        if (isRealtimeErrorMessageError(e_5)) {
                            msg = e_5.payload;
                            switch (msg.msgData.code) {
                                case 'CHECK_LOGIN_FAILED':
                                case 'SIGN_EXPIRED_ERROR':
                                case 'SIGN_INVALID_ERROR':
                                case 'SIGN_PARAM_INVALID': {
                                    this.rebuildWatch();
                                    return [2];
                                }
                                case 'QUERYID_INVALID_ERROR':
                                case 'SYS_ERR':
                                case 'INVALIID_ENV':
                                case 'COLLECTION_PERMISSION_DENIED': {
                                    this.closeWithError(new CloudSDKError({
                                        errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                                        errMsg: msg.msgData.code,
                                    }));
                                    return [2];
                                }
                                default: {
                                    break;
                                }
                            }
                        }
                        if (this._availableRetries.CHECK_LAST
                            && this._availableRetries.CHECK_LAST > 0) {
                            this._availableRetries.CHECK_LAST--;
                            this.scheduleSendACK();
                        }
                        else {
                            this.closeWithError(new CloudSDKError({
                                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                                errMsg: e_5,
                            }));
                        }
                        return [3, 3];
                    case 3: return [2];
                }
            });
        }); };
        this.handleCommonError = function (e, options) {
            if (isRealtimeErrorMessageError(e)) {
                var msg = e.payload;
                switch (msg.msgData.code) {
                    case 'CHECK_LOGIN_FAILED':
                    case 'SIGN_EXPIRED_ERROR':
                    case 'SIGN_INVALID_ERROR':
                    case 'SIGN_PARAM_INVALID': {
                        options.onSignError(e);
                        return;
                    }
                    case 'QUERYID_INVALID_ERROR':
                    case 'SYS_ERR':
                    case 'INVALIID_ENV':
                    case 'COLLECTION_PERMISSION_DENIED': {
                        options.onNotRetryableError(e);
                        return;
                    }
                    default: {
                        options.onNotRetryableError(e);
                        return;
                    }
                }
            }
            else if (isTimeoutError(e)) {
                options.onTimeoutError(e);
                return;
            }
            else if (isCancelledError(e)) {
                options.onCancelledError(e);
                return;
            }
            options.onUnknownError(e);
        };
        this.watchId = "watchid_".concat(+new Date(), "_").concat(Math.random());
        this.envId = options.envId;
        this.collectionName = options.collectionName;
        this.query = options.query;
        this.limit = options.limit;
        this.orderBy = options.orderBy;
        this.send = options.send;
        this.login = options.login;
        this.isWSConnected = options.isWSConnected;
        this.onceWSConnected = options.onceWSConnected;
        this.getWaitExpectedTimeoutLength = options.getWaitExpectedTimeoutLength;
        this.onWatchStart = options.onWatchStart;
        this.onWatchClose = options.onWatchClose;
        this.debug = options.debug;
        this._availableRetries = {
            INIT_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
            REBUILD_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
            CHECK_LAST: DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR,
        };
        this.listener = new RealtimeListener({
            close: this.closeWatch,
            onChange: options.onChange,
            onError: options.onError,
            debug: this.debug,
            virtualClient: this,
        });
        this.initWatch();
    }
    VirtualWebSocketClient.prototype.onMessage = function (msg) {
        var _this = this;
        switch (this.watchStatus) {
            case WATCH_STATUS.PAUSED: {
                if (msg.msgType !== 'ERROR') {
                    return;
                }
                break;
            }
            case WATCH_STATUS.LOGGINGIN:
            case WATCH_STATUS.INITING:
            case WATCH_STATUS.REBUILDING: {
                console.warn("[realtime listener] internal non-fatal error: unexpected message received while ".concat(this.watchStatus));
                return;
            }
            case WATCH_STATUS.CLOSED: {
                console.warn('[realtime listener] internal non-fatal error: unexpected message received when the watch has closed');
                return;
            }
            case WATCH_STATUS.ERRORED: {
                console.warn('[realtime listener] internal non-fatal error: unexpected message received when the watch has ended with error');
                return;
            }
        }
        if (!this.sessionInfo) {
            console.warn('[realtime listener] internal non-fatal error: sessionInfo not found while message is received.');
            return;
        }
        this.scheduleSendACK();
        switch (msg.msgType) {
            case 'NEXT_EVENT': {
                console.warn("nextevent ".concat(msg.msgData.currEvent, " ignored"), msg);
                this.handleServerEvents(msg);
                break;
            }
            case 'CHECK_EVENT': {
                if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
                    this.sessionInfo.expectEventId = msg.msgData.currEvent;
                    this.clearWaitExpectedEvent();
                    this._waitExpectedTimeoutId = setTimeout(function () {
                        _this.rebuildWatch();
                    }, this.getWaitExpectedTimeoutLength());
                    console.log("[realtime] waitExpectedTimeoutLength ".concat(this.getWaitExpectedTimeoutLength()));
                }
                break;
            }
            case 'ERROR': {
                this.closeWithError(new CloudSDKError({
                    errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG,
                    errMsg: "".concat(msg.msgData.code, " - ").concat(msg.msgData.message),
                }));
                break;
            }
            default: {
                console.warn("[realtime listener] virtual client receive unexpected msg ".concat(msg.msgType, ": "), msg);
                break;
            }
        }
    };
    VirtualWebSocketClient.prototype.closeWithError = function (error) {
        var _a;
        this.watchStatus = WATCH_STATUS.ERRORED;
        this.clearACKSchedule();
        this.listener.onError(error);
        this.onWatchClose(this, ((_a = this.sessionInfo) === null || _a === void 0 ? void 0 : _a.queryID) || '');
        console.log("[realtime] client closed (".concat(this.collectionName, " ").concat(this.query, ") (watchId ").concat(this.watchId, ")"));
    };
    VirtualWebSocketClient.prototype.pause = function () {
        this.watchStatus = WATCH_STATUS.PAUSED;
        console.log("[realtime] client paused (".concat(this.collectionName, " ").concat(this.query, ") (watchId ").concat(this.watchId, ")"));
    };
    VirtualWebSocketClient.prototype.resume = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.watchStatus = WATCH_STATUS.RESUMING;
                        console.log("[realtime] client resuming with ".concat(this.sessionInfo ? 'REBUILD_WATCH' : 'INIT_WATCH', " (").concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, (this.sessionInfo ? this.rebuildWatch() : this.initWatch())];
                    case 2:
                        _a.sent();
                        console.log("[realtime] client successfully resumed (".concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"));
                        return [3, 4];
                    case 3:
                        e_6 = _a.sent();
                        console.error("[realtime] client resume failed (".concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"), e_6);
                        return [3, 4];
                    case 4: return [2];
                }
            });
        });
    };
    VirtualWebSocketClient.prototype.useRetryTicket = function (operationName) {
        if (this._availableRetries[operationName]
            && this._availableRetries[operationName] > 0) {
            this._availableRetries[operationName]--;
            console.log("[realtime] ".concat(operationName, " use a retry ticket, now only ").concat(this._availableRetries[operationName], " retry left"));
            return true;
        }
        return false;
    };
    VirtualWebSocketClient.prototype.handleServerEvents = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var e_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        this.scheduleSendACK();
                        return [4, this._handleServerEvents(msg)];
                    case 1:
                        _a.sent();
                        this._postHandleServerEventsValidityCheck(msg);
                        return [3, 3];
                    case 2:
                        e_7 = _a.sent();
                        console.error('[realtime listener] internal non-fatal error: handle server events failed with error: ', e_7);
                        throw e_7;
                    case 3: return [2];
                }
            });
        });
    };
    VirtualWebSocketClient.prototype._handleServerEvents = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var requestId, events, msgType, sessionInfo, allChangeEvents, docs, initEncountered, _loop_1, this_1, i, len, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestId = msg.requestId;
                        events = msg.msgData.events;
                        msgType = msg.msgType;
                        if (!events.length || !this.sessionInfo) {
                            return [2];
                        }
                        sessionInfo = this.sessionInfo;
                        try {
                            allChangeEvents = events.map(getPublicEvent);
                        }
                        catch (e) {
                            this.closeWithError(new CloudSDKError({
                                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA,
                                errMsg: e,
                            }));
                            return [2];
                        }
                        docs = __spreadArray([], sessionInfo.currentDocs, true);
                        initEncountered = false;
                        _loop_1 = function (i, len) {
                            var change, localDoc, doc, fieldPath, _i, _b, fieldPath, err, err, doc, doc, err, ind, ind, docsSnapshot, docChanges, snapshot;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        change = allChangeEvents[i];
                                        if (!(sessionInfo.currentEventId >= change.id)) return [3, 1];
                                        if (!allChangeEvents[i - 1] || change.id > allChangeEvents[i - 1].id) {
                                            console.warn("[realtime] duplicate event received, cur ".concat(sessionInfo.currentEventId, " but got ").concat(change.id));
                                        }
                                        else {
                                            console.error("[realtime listener] server non-fatal error: events out of order (the latter event's id is smaller than that of the former) (requestId ".concat(requestId, ")"));
                                        }
                                        return [2, "continue"];
                                    case 1:
                                        if (!(sessionInfo.currentEventId === change.id - 1)) return [3, 2];
                                        switch (change.dataType) {
                                            case 'update': {
                                                if (!change.doc) {
                                                    switch (change.queueType) {
                                                        case 'update':
                                                        case 'dequeue': {
                                                            localDoc = docs.find(function (doc) { return doc._id === change.docId; });
                                                            if (localDoc) {
                                                                doc = cloneDeep(localDoc);
                                                                if (change.updatedFields) {
                                                                    for (fieldPath in change.updatedFields) {
                                                                        set(doc, fieldPath, change.updatedFields[fieldPath]);
                                                                    }
                                                                }
                                                                if (change.removedFields) {
                                                                    for (_i = 0, _b = change.removedFields; _i < _b.length; _i++) {
                                                                        fieldPath = _b[_i];
                                                                        unset(doc, fieldPath);
                                                                    }
                                                                }
                                                                change.doc = doc;
                                                            }
                                                            else {
                                                                console.error('[realtime listener] internal non-fatal server error: unexpected update dataType event where no doc is associated.');
                                                            }
                                                            break;
                                                        }
                                                        case 'enqueue': {
                                                            err = new CloudSDKError({
                                                                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                                                errMsg: "HandleServerEvents: full doc is not provided with dataType=\"update\" and queueType=\"enqueue\" (requestId ".concat(msg.requestId, ")"),
                                                            });
                                                            this_1.closeWithError(err);
                                                            throw err;
                                                        }
                                                        default: {
                                                            break;
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                            case 'replace': {
                                                if (!change.doc) {
                                                    err = new CloudSDKError({
                                                        errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                                        errMsg: "HandleServerEvents: full doc is not provided with dataType=\"replace\" (requestId ".concat(msg.requestId, ")"),
                                                    });
                                                    this_1.closeWithError(err);
                                                    throw err;
                                                }
                                                break;
                                            }
                                            case 'remove': {
                                                doc = docs.find(function (doc) { return doc._id === change.docId; });
                                                if (doc) {
                                                    change.doc = doc;
                                                }
                                                else {
                                                    console.error('[realtime listener] internal non-fatal server error: unexpected remove event where no doc is associated.');
                                                }
                                                break;
                                            }
                                            case 'limit': {
                                                if (!change.doc) {
                                                    switch (change.queueType) {
                                                        case 'dequeue': {
                                                            doc = docs.find(function (doc) { return doc._id === change.docId; });
                                                            if (doc) {
                                                                change.doc = doc;
                                                            }
                                                            else {
                                                                console.error('[realtime listener] internal non-fatal server error: unexpected limit dataType event where no doc is associated.');
                                                            }
                                                            break;
                                                        }
                                                        case 'enqueue': {
                                                            err = new CloudSDKError({
                                                                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                                                errMsg: "HandleServerEvents: full doc is not provided with dataType=\"limit\" and queueType=\"enqueue\" (requestId ".concat(msg.requestId, ")"),
                                                            });
                                                            this_1.closeWithError(err);
                                                            throw err;
                                                        }
                                                        default: {
                                                            break;
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                        switch (change.queueType) {
                                            case 'init': {
                                                if (!initEncountered) {
                                                    initEncountered = true;
                                                    docs = [change.doc];
                                                }
                                                else {
                                                    docs.push(change.doc);
                                                }
                                                break;
                                            }
                                            case 'enqueue': {
                                                docs.push(change.doc);
                                                break;
                                            }
                                            case 'dequeue': {
                                                ind = docs.findIndex(function (doc) { return doc._id === change.docId; });
                                                if (ind > -1) {
                                                    docs.splice(ind, 1);
                                                }
                                                else {
                                                    console.error('[realtime listener] internal non-fatal server error: unexpected dequeue event where no doc is associated.');
                                                }
                                                break;
                                            }
                                            case 'update': {
                                                ind = docs.findIndex(function (doc) { return doc._id === change.docId; });
                                                if (ind > -1) {
                                                    docs[ind] = change.doc;
                                                }
                                                else {
                                                    console.error('[realtime listener] internal non-fatal server error: unexpected queueType update event where no doc is associated.');
                                                }
                                                break;
                                            }
                                        }
                                        if (i === len - 1
                                            || (allChangeEvents[i + 1] && allChangeEvents[i + 1].id !== change.id)) {
                                            docsSnapshot = __spreadArray([], docs, true);
                                            docChanges = allChangeEvents
                                                .slice(0, i + 1)
                                                .filter(function (c) { return c.id === change.id; });
                                            this_1.sessionInfo.currentEventId = change.id;
                                            this_1.sessionInfo.currentDocs = docs;
                                            snapshot = new Snapshot({
                                                id: change.id,
                                                docChanges: docChanges,
                                                docs: docsSnapshot,
                                                msgType: msgType,
                                            });
                                            this_1.listener.onChange(snapshot);
                                        }
                                        return [3, 4];
                                    case 2:
                                        console.warn("[realtime listener] event received is out of order, cur ".concat(this_1.sessionInfo.currentEventId, " but got ").concat(change.id));
                                        return [4, this_1.rebuildWatch()];
                                    case 3:
                                        _c.sent();
                                        return [2, { value: void 0 }];
                                    case 4: return [2];
                                }
                            });
                        };
                        this_1 = this;
                        i = 0, len = allChangeEvents.length;
                        _a.label = 1;
                    case 1:
                        if (!(i < len)) return [3, 4];
                        return [5, _loop_1(i, len)];
                    case 2:
                        state_1 = _a.sent();
                        if (typeof state_1 === "object")
                            return [2, state_1.value];
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    VirtualWebSocketClient.prototype._postHandleServerEventsValidityCheck = function (msg) {
        if (!this.sessionInfo) {
            console.error('[realtime listener] internal non-fatal error: sessionInfo lost after server event handling, this should never occur');
            return;
        }
        if (this.sessionInfo.expectEventId
            && this.sessionInfo.currentEventId >= this.sessionInfo.expectEventId) {
            this.clearWaitExpectedEvent();
        }
        if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
            console.warn('[realtime listener] internal non-fatal error: client eventId does not match with server event id after server event handling');
            return;
        }
    };
    VirtualWebSocketClient.prototype.clearWaitExpectedEvent = function () {
        if (this._waitExpectedTimeoutId) {
            clearTimeout(this._waitExpectedTimeoutId);
            this._waitExpectedTimeoutId = undefined;
        }
    };
    return VirtualWebSocketClient;
}());
export { VirtualWebSocketClient };
function getPublicEvent(event) {
    var e = {
        id: event.ID,
        dataType: event.DataType,
        queueType: event.QueueType,
        docId: event.DocID,
        doc: event.Doc && event.Doc !== '{}' ? JSON.parse(event.Doc) : undefined,
    };
    if (event.DataType === 'update') {
        if (event.UpdatedFields) {
            e.updatedFields = JSON.parse(event.UpdatedFields);
        }
        if (event.removedFields || event.RemovedFields) {
            e.removedFields = JSON.parse(event.removedFields);
        }
    }
    return e;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC13ZWJzb2NrZXQtY2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ZpcnR1YWwtd2Vic29ja2V0LWNsaWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxPQUFPLEdBQUcsTUFBTSxZQUFZLENBQUM7QUFDN0IsT0FBTyxLQUFLLE1BQU0sY0FBYyxDQUFDO0FBQ2pDLE9BQU8sU0FBUyxNQUFNLGtCQUFrQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFpQnpDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUM5QyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRXRDLE9BQU8sRUFDTCxRQUFRLEVBQ1IsYUFBYSxFQUNiLGNBQWMsRUFDZCxjQUFjLEVBQ2QsZ0JBQWdCLEVBQ2hCLDJCQUEyQixHQUc1QixNQUFNLFNBQVMsQ0FBQztBQUNqQixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBNENoQyxJQUFLLFlBVUo7QUFWRCxXQUFLLFlBQVk7SUFDZix1Q0FBdUIsQ0FBQTtJQUN2QixtQ0FBbUIsQ0FBQTtJQUNuQix5Q0FBeUIsQ0FBQTtJQUN6QixpQ0FBaUIsQ0FBQTtJQUNqQixtQ0FBbUIsQ0FBQTtJQUNuQixtQ0FBbUIsQ0FBQTtJQUNuQixpQ0FBaUIsQ0FBQTtJQUNqQixpQ0FBaUIsQ0FBQTtJQUNqQixxQ0FBcUIsQ0FBQTtBQUN2QixDQUFDLEVBVkksWUFBWSxLQUFaLFlBQVksUUFVaEI7QUFFRCxJQUFNLGtDQUFrQyxHQUFHLEdBQUcsQ0FBQztBQUMvQyxJQUFNLCtCQUErQixHQUFHLENBQUMsQ0FBQztBQUMxQyxJQUFNLHdDQUF3QyxHQUFHLENBQUMsQ0FBQztBQUNuRCxJQUFNLGlDQUFpQyxHQUFHLEVBQUUs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QUssQ0FBQyxTQUFTO1FBQzFCLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSztRQUNsQixHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsSUFBSSxLQUFLLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVM7S0FDekUsQ0FBQztJQUVGLElBQUksS0FBSyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7UUFFL0IsSUFBSSxLQUFLLENBQUMsYUFBYSxFQUFFO1lBQ3ZCLENBQUMsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbkQ7UUFHRCxJQUFJLEtBQUssQ0FBQyxhQUFhLElBQUksS0FBSyxDQUFDLGFBQWEsRUFBRTtZQUs5QyxDQUFDLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ25EO0tBQ0Y7SUFFRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1wbHVzcGx1cyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXMgKi9cbmltcG9ydCBzZXQgZnJvbSAnbG9kYXNoLnNldCc7XG5pbXBvcnQgdW5zZXQgZnJvbSAnbG9kYXNoLnVuc2V0JztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XG5pbXBvcnQgeyBnZW5SZXF1ZXN0SWQgfSBmcm9tICcuL21lc3NhZ2UnO1xuaW1wb3J0IHtcbiAgSVJlc3BvbnNlTWVzc2FnZSxcbiAgSVJlcXVlc3RNZXNzYWdlSW5pdFdhdGNoTXNnLFxuICBJUmVzcG9uc2VNZXNzYWdlSW5pdEV2ZW50TXNnLFxuICBJREJFdmVudCxcbiAgSVJlcXVlc3RNZXNzYWdlUmVidWlsZFdhdGNoTXNnLFxuICBJUmVxdWVzdE1lc3NhZ2VDbG9zZVdhdGNoTXNnLFxuICBJUmVxdWVzdE1zZ1R5cGUsXG4gIElSZXNwb25zZU1lc3NhZ2VOZXh0RXZlbnRNc2csXG4gIElSZXF1ZXN0TWVzc2FnZUNoZWNrTGFzdE1zZyxcbiAgSVdhdGNoT3B0aW9ucyxcbn0gZnJvbSAnQGNsb3VkYmFzZS90eXBlcy9yZWFsdGltZSc7XG5pbXBvcnQge1xuICBJU2luZ2xlREJFdmVudCxcbn0gZnJvbSAnQGNsb3VkYmFzZS90eXBlcy9kYXRhYmFzZSc7XG4vLyBpbXBvcnQgUmVwb3J0ZXIgZnJvbSBcIi4vZXh0ZXJuYWxzL3B1YmxpYy1saWIvcmVwb3J0ZXJcIlxuaW1wb3J0IHsgUmVhbHRpbWVMaXN0ZW5lciB9IGZyb20gJy4vbGlzdGVuZXInO1xuaW1wb3J0IHsgU25hcHNob3QgfSBmcm9tICcuL3NuYXBzaG90JztcbmltcG9ydCB7IElXU1NlbmRPcHRpb25zLCBJTG9naW5SZXN1bHQgfSBmcm9tICcuL3dlYnNvY2tldC1jbGllbnQnO1xuaW1wb3J0IHtcbiAgRVJSX0NPREUsXG4gIENsb3VkU0RLRXJyb3IsXG4gIGlzVGltZW91dEVycm9yLFxuICBDYW5jZWxsZWRFcnJvcixcbiAgaXNDYW5jZWxsZWRFcnJvcixcbiAgaXNSZWFsdGltZUVycm9yTWVzc2FnZUVycm9yLFxuICBSZWFsdGltZUVycm9yTWVzc2FnZUVycm9yLFxuICBUaW1lb3V0RXJyb3IsXG59IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09IFJlYWx0aW1lIFZpcnR1YWwgV2ViU29ja2V0IENsaWVudCAoSW50ZXJuYWwpID09PT09PT09PT09PT09PT09PT09XG5cbmludGVyZmFjZSBJVmlydHVhbFdlYlNvY2tldENsaWVudENvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIElXYXRjaE9wdGlvbnMge1xuICAvLyB3czogUmVhbHRpbWVXZWJTb2NrZXRDbGllbnRcbiAgZW52SWQ/OiBzdHJpbmdcbiAgY29sbGVjdGlvbk5hbWU6IHN0cmluZ1xuICBxdWVyeTogc3RyaW5nXG4gIGxpbWl0PzogbnVtYmVyXG4gIG9yZGVyQnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHNlbmQ6IDxUID0gYW55PihvcHRzOiBJV1NTZW5kT3B0aW9ucykgPT4gUHJvbWlzZTxUPlxuICBsb2dpbjogKGVudklkPzogc3RyaW5nLCByZWZyZXNoPzogYm9vbGVhbikgPT4gUHJvbWlzZTxhbnk+XG4gIGlzV1NDb25uZWN0ZWQ6ICgpID0+IGJvb2xlYW5cbiAgb25jZVdTQ29ubmVjdGVkOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGdldFdhaXRFeHBlY3RlZFRpbWVvdXRMZW5ndGg6ICgpID0+IG51bWJlclxuICBvbldhdGNoU3RhcnQ6IChjbGllbnQ6IFZpcnR1YWxXZWJTb2NrZXRDbGllbnQsIHF1ZXJ5SUQ6IHN0cmluZykgPT4gdm9pZFxuICBvbldhdGNoQ2xvc2U6IChjbGllbnQ6IFZpcnR1YWxXZWJTb2NrZXRDbGllbnQsIHF1ZXJ5SUQ6IHN0cmluZykgPT4gdm9pZFxuICBkZWJ1Zz86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIElXYXRjaFNlc3Npb25JbmZvIHtcbiAgcXVlcnlJRDogc3RyaW5nXG4gIGN1cnJlbnRFdmVudElkOiBudW1iZXJcbiAgY3VycmVudERvY3M6IFJlY29yZDxzdHJpbmcsIGFueT5bXVxuICBleHBlY3RFdmVudElkPzogbnVtYmVyXG59XG5cbmludGVyZmFjZSBJSGFuZGxlQ29tbW9uRXJyb3JPcHRpb25zIHtcbiAgb25TaWduRXJyb3I6IChlOiBSZWFsdGltZUVycm9yTWVzc2FnZUVycm9yKSA9PiB2b2lkXG4gIG9uVGltZW91dEVycm9yOiAoZTogVGltZW91dEVycm9yKSA9PiB2b2lkXG4gIG9uQ2FuY2VsbGVkRXJyb3I6IChlOiBDYW5jZWxsZWRFcnJvcikgPT4gdm9pZFxuICBvbk5vdFJldHJ5YWJsZUVycm9yOiAoZTogUmVhbHRpbWVFcnJvck1lc3NhZ2VFcnJvcikgPT4gdm9pZFxuICBvblVua25vd25FcnJvcjogKGU6IGFueSkgPT4gdm9pZFxufVxuXG5pbnRlcmZhY2UgSUhhbmRsZVdhdGNoRXN0YWJsaXNobWVudEVycm9yT3B0aW9ucyB7XG4gIG9wZXJhdGlvbk5hbWU6ICdJTklUX1dBVENIJyB8ICdSRUJVSUxEX1dBVENIJ1xuICByZXNvbHZlOiAodmFsdWU/OiBQcm9taXNlTGlrZTx2b2lkPiB8IHVuZGVmaW5lZCkgPT4gdm9pZFxuICByZWplY3Q6IChlOiBhbnkpID0+IHZvaWRcbiAgLy8gcmV0cnk6IChyZWZyZXNoTG9naW4/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8vIGFib3J0V2F0Y2g6IChlOiBhbnkpID0+IHZvaWRcbn1cblxuZW51bSBXQVRDSF9TVEFUVVMge1xuICBMT0dHSU5HSU4gPSAnTE9HR0lOR0lOJyxcbiAgSU5JVElORyA9ICdJTklUSU5HJyxcbiAgUkVCVUlMRElORyA9ICdSRUJVSUxESU5HJyxcbiAgQUNUSVZFID0gJ0FDVElWRScsXG4gIEVSUk9SRUQgPSAnRVJST1JFRCcsXG4gIENMT1NJTkcgPSAnQ0xPU0lORycsXG4gIENMT1NFRCA9ICdDTE9TRUQnLFxuICBQQVVTRUQgPSAnUEFVU0VEJyxcbiAgUkVTVU1JTkcgPSAnUkVTVU1JTkcnXG59XG5cbmNvbnN0IERFRkFVTFRfV0FJVF9USU1FX09OX1VOS05PV05fRVJST1IgPSAxMDA7XG5jb25zdCBERUZBVUxUX01BWF9BVVRPX1JFVFJZX09OX0VSUk9SID0gMjtcbmNvbnN0IERFRkFVTFRfTUFYX1NFTkRfQUNLX0FVVE9fUkVUUllfT05fRVJST1IgPSAyO1xuY29uc3QgREVGQVVMVF9TRU5EX0FDS19ERUJPVU5DRV9USU1FT1VUID0gMTAgKiAxMDAwO1xuY29uc3QgREVGQVVMVF9JTklUX1dBVENIX1RJTUVPVVQgPSAxMCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX1JFQlVJTERfV0FUQ0hfVElNRU9VVCA9IDEwICogMTAwMDtcblxuZXhwb3J0IGNsYXNzIFZpcnR1YWxXZWJTb2NrZXRDbGllbnQge1xuICAvLyBwYXNzZWQgb3ZlclxuICB3YXRjaElkOiBzdHJpbmc7XG4gIC8vIG93blxuICBsaXN0ZW5lcjogUmVhbHRpbWVMaXN0ZW5lcjtcbiAgcHJpdmF0ZSBlbnZJZD86IHN0cmluZztcbiAgcHJpdmF0ZSBjb2xsZWN0aW9uTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHF1ZXJ5OiBzdHJpbmc7XG4gIHByaXZhdGUgbGltaXQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBvcmRlckJ5OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBwcml2YXRlIHNlbmQ6IDxUID0gYW55PihvcHRzOiBJV1NTZW5kT3B0aW9ucykgPT4gUHJvbWlzZTxUPjtcbiAgcHJpdmF0ZSBsb2dpbjogKGVudklkPzogc3RyaW5nLCByZWZyZXNoPzogYm9vbGVhbikgPT4gUHJvbWlzZTxhbnk+O1xuICBwcml2YXRlIGlzV1NDb25uZWN0ZWQ6ICgpID0+IGJvb2xlYW47XG4gIHByaXZhdGUgb25jZVdTQ29ubmVjdGVkOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIGdldFdhaXRFeHBlY3RlZFRpbWVvdXRMZW5ndGg6ICgpID0+IG51bWJlcjtcbiAgcHJpdmF0ZSBvbldhdGNoU3RhcnQ6IChcbiAgICBjbGllbnQ6IFZpcnR1YWxXZWJTb2NrZXRDbGllbnQsXG4gICAgcXVlcnlJRDogc3RyaW5nXG4gICkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBvbldhdGNoQ2xvc2U6IChcbiAgICBjbGllbnQ6IFZpcnR1YWxXZWJTb2NrZXRDbGllbnQsXG4gICAgcXVlcnlJRDogc3RyaW5nXG4gICkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBkZWJ1Zz86IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSB3YXRjaFN0YXR1czogV0FUQ0hfU1RBVFVTID0gV0FUQ0hfU1RBVFVTLklOSVRJTkc7XG4gIHByaXZhdGUgX2F2YWlsYWJsZVJldHJpZXM6IFBhcnRpYWw8UmVjb3JkPElSZXF1ZXN0TXNnVHlwZSwgbnVtYmVyPj47XG4gIHByaXZhdGUgX2Fja1RpbWVvdXRJZD86IG51bWJlcjtcbiAgcHJpdmF0ZSBfaW5pdFdhdGNoUHJvbWlzZT86IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgX3JlYnVpbGRXYXRjaFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vIG9idGFpbmVkXG4gIHByaXZhdGUgc2Vzc2lvbkluZm8/OiBJV2F0Y2hTZXNzaW9uSW5mbztcblxuICAvLyBpbnRlcm5hbFxuICBwcml2YXRlIF93YWl0RXhwZWN0ZWRUaW1lb3V0SWQ/OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogSVZpcnR1YWxXZWJTb2NrZXRDbGllbnRDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICB0aGlzLndhdGNoSWQgPSBgd2F0Y2hpZF8keytuZXcgRGF0ZSgpfV8ke01hdGgucmFuZG9tKCl9YDtcbiAgICB0aGlzLmVudklkID0gb3B0aW9ucy5lbnZJZDtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gb3B0aW9ucy5jb2xsZWN0aW9uTmFtZTtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0aW9ucy5xdWVyeTtcbiAgICB0aGlzLmxpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICB0aGlzLm9yZGVyQnkgPSBvcHRpb25zLm9yZGVyQnk7XG4gICAgdGhpcy5zZW5kID0gb3B0aW9ucy5zZW5kO1xuICAgIHRoaXMubG9naW4gPSBvcHRpb25zLmxvZ2luO1xuICAgIHRoaXMuaXNXU0Nvbm5lY3RlZCA9IG9wdGlvbnMuaXNXU0Nvbm5lY3RlZDtcbiAgICB0aGlzLm9uY2VXU0Nvbm5lY3RlZCA9IG9wdGlvbnMub25jZVdTQ29ubmVjdGVkO1xuICAgIHRoaXMuZ2V0V2FpdEV4cGVjdGVkVGltZW91dExlbmd0aCA9IG9wdGlvbnMuZ2V0V2FpdEV4cGVjdGVkVGltZW91dExlbmd0aDtcbiAgICB0aGlzLm9uV2F0Y2hTdGFydCA9IG9wdGlvbnMub25XYXRjaFN0YXJ0O1xuICAgIHRoaXMub25XYXRjaENsb3NlID0gb3B0aW9ucy5vbldhdGNoQ2xvc2U7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgICB0aGlzLl9hdmFpbGFibGVSZXRyaWVzID0ge1xuICAgICAgSU5JVF9XQVRDSDogREVGQVVMVF9NQVhfQVVUT19SRVRSWV9PTl9FUlJPUixcbiAgICAgIFJFQlVJTERfV0FUQ0g6IERFRkFVTFRfTUFYX0FVVE9fUkVUUllfT05fRVJST1IsXG4gICAgICBDSEVDS19MQVNUOiBERUZBVUxUX01BWF9TRU5EX0FDS19BVVRPX1JFVFJZX09OX0VSUk9SLFxuICAgIH07XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gbmV3IFJlYWx0aW1lTGlzdGVuZXIoe1xuICAgICAgY2xvc2U6IHRoaXMuY2xvc2VXYXRjaCxcbiAgICAgIG9uQ2hhbmdlOiBvcHRpb25zLm9uQ2hhbmdlLFxuICAgICAgb25FcnJvcjogb3B0aW9ucy5vbkVycm9yLFxuICAgICAgZGVidWc6IHRoaXMuZGVidWcsXG4gICAgICB2aXJ0dWFsQ2xpZW50OiB0aGlzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0V2F0Y2goKTtcbiAgfVxuXG4gIG9uTWVzc2FnZShtc2c6IElSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAvLyB3YXRjaFN0YXR1cyBzYW5pdHkgY2hlY2tcbiAgICBzd2l0Y2ggKHRoaXMud2F0Y2hTdGF0dXMpIHtcbiAgICAgIGNhc2UgV0FUQ0hfU1RBVFVTLlBBVVNFRDoge1xuICAgICAgICAvLyBpZ25vcmUgYWxsIGJ1dCBlcnJvciBtZXNzYWdlXG4gICAgICAgIGlmIChtc2cubXNnVHlwZSAhPT0gJ0VSUk9SJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgV0FUQ0hfU1RBVFVTLkxPR0dJTkdJTjpcbiAgICAgIGNhc2UgV0FUQ0hfU1RBVFVTLklOSVRJTkc6XG4gICAgICBjYXNlIFdBVENIX1NUQVRVUy5SRUJVSUxESU5HOiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IHVuZXhwZWN0ZWQgbWVzc2FnZSByZWNlaXZlZCB3aGlsZSAke3RoaXMud2F0Y2hTdGF0dXN9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgV0FUQ0hfU1RBVFVTLkNMT1NFRDoge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIGVycm9yOiB1bmV4cGVjdGVkIG1lc3NhZ2UgcmVjZWl2ZWQgd2hlbiB0aGUgd2F0Y2ggaGFzIGNsb3NlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIFdBVENIX1NUQVRVUy5FUlJPUkVEOiB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IHVuZXhwZWN0ZWQgbWVzc2FnZSByZWNlaXZlZCB3aGVuIHRoZSB3YXRjaCBoYXMgZW5kZWQgd2l0aCBlcnJvcicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNlc3Npb25JbmZvKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIGVycm9yOiBzZXNzaW9uSW5mbyBub3QgZm91bmQgd2hpbGUgbWVzc2FnZSBpcyByZWNlaXZlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlU2VuZEFDSygpO1xuXG4gICAgc3dpdGNoIChtc2cubXNnVHlwZSkge1xuICAgICAgY2FzZSAnTkVYVF9FVkVOVCc6IHtcbiAgICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gaWYgKHd4Ll9pZ25vcmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBuZXh0ZXZlbnQgJHttc2cubXNnRGF0YS5jdXJyRXZlbnR9IGlnbm9yZWRgLCBtc2cpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIHd4Ll9pZ25vcmUgPSBmYWxzZVxuICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVTZXJ2ZXJFdmVudHMobXNnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdDSEVDS19FVkVOVCc6IHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWQgPCBtc2cubXNnRGF0YS5jdXJyRXZlbnQpIHtcbiAgICAgICAgICAvLyBjbGllbnQgZXZlbnRJRCA8IHNlcnZlciBldmVudElEOlxuICAgICAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIG9uZSBvciBtb3JlIHBlbmRpbmcgZXZlbnRzIG5vdCB5ZXQgcmVjZWl2ZWQgYnV0IHNlbnQgYnkgdGhlIHNlcnZlclxuICAgICAgICAgIHRoaXMuc2Vzc2lvbkluZm8uZXhwZWN0RXZlbnRJZCA9IG1zZy5tc2dEYXRhLmN1cnJFdmVudDtcbiAgICAgICAgICB0aGlzLmNsZWFyV2FpdEV4cGVjdGVkRXZlbnQoKTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5fd2FpdEV4cGVjdGVkVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBtdXN0IHJlYnVpbGQgd2F0Y2hcbiAgICAgICAgICAgIHRoaXMucmVidWlsZFdhdGNoKCk7XG4gICAgICAgICAgfSwgdGhpcy5nZXRXYWl0RXhwZWN0ZWRUaW1lb3V0TGVuZ3RoKCkpO1xuXG4gICAgICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtyZWFsdGltZV0gd2FpdEV4cGVjdGVkVGltZW91dExlbmd0aCAke3RoaXMuZ2V0V2FpdEV4cGVjdGVkVGltZW91dExlbmd0aCgpfWApO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0VSUk9SJzoge1xuICAgICAgICAvLyByZWNlaXZlIHNlcnZlciBlcnJvclxuICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgICBlcnJDb2RlOiBFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfU0VSVkVSX0VSUk9SX01TRyBhcyBzdHJpbmcsXG4gICAgICAgICAgZXJyTXNnOiBgJHttc2cubXNnRGF0YS5jb2RlfSAtICR7bXNnLm1zZ0RhdGEubWVzc2FnZX1gLFxuICAgICAgICB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIHZpcnR1YWwgY2xpZW50IHJlY2VpdmUgdW5leHBlY3RlZCBtc2cgJHttc2cubXNnVHlwZX06IGAsXG4gICAgICAgICAgbXNnXG4gICAgICAgICk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xvc2VXaXRoRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuRVJST1JFRDtcbiAgICB0aGlzLmNsZWFyQUNLU2NoZWR1bGUoKTtcbiAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgIC8vIFJlcG9ydGVyLnN1cnJvdW5kVGhpcmRCeVRyeUNhdGNoKCgpID0+IHRoaXMubGlzdGVuZXIub25FcnJvcihlcnJvcikpXG4gICAgdGhpcy5vbldhdGNoQ2xvc2UoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5zZXNzaW9uSW5mbz8ucXVlcnlJRCB8fCAnJ1xuICAgICk7XG5cbiAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSBjbGllbnQgY2xvc2VkICgke3RoaXMuY29sbGVjdGlvbk5hbWV9ICR7dGhpcy5xdWVyeX0pICh3YXRjaElkICR7dGhpcy53YXRjaElkfSlgKTtcbiAgICAvLyB9XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLndhdGNoU3RhdHVzID0gV0FUQ0hfU1RBVFVTLlBBVVNFRDtcbiAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSBjbGllbnQgcGF1c2VkICgke3RoaXMuY29sbGVjdGlvbk5hbWV9ICR7dGhpcy5xdWVyeX0pICh3YXRjaElkICR7dGhpcy53YXRjaElkfSlgKTtcbiAgICAvLyB9XG4gIH1cblxuICAvLyByZXN1bWUoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkluZm8gPyB0aGlzLnJlYnVpbGRXYXRjaCgpIDogdGhpcy5pbml0V2F0Y2goKVxuICAvLyB9XG5cbiAgYXN5bmMgcmVzdW1lKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuUkVTVU1JTkc7XG5cbiAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSBjbGllbnQgcmVzdW1pbmcgd2l0aCAke1xuICAgICAgdGhpcy5zZXNzaW9uSW5mbyA/ICdSRUJVSUxEX1dBVENIJyA6ICdJTklUX1dBVENIJ1xuICAgIH0gKCR7dGhpcy5jb2xsZWN0aW9uTmFtZX0gJHt0aGlzLnF1ZXJ5fSkgKCR7dGhpcy53YXRjaElkfSlgKTtcbiAgICAvLyB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgKHRoaXMuc2Vzc2lvbkluZm8gPyB0aGlzLnJlYnVpbGRXYXRjaCgpIDogdGhpcy5pbml0V2F0Y2goKSk7XG5cbiAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgY29uc29sZS5sb2coYFtyZWFsdGltZV0gY2xpZW50IHN1Y2Nlc3NmdWxseSByZXN1bWVkICgke3RoaXMuY29sbGVjdGlvbk5hbWV9ICR7dGhpcy5xdWVyeX0pICgke3RoaXMud2F0Y2hJZH0pYCk7XG4gICAgICAvLyB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgW3JlYWx0aW1lXSBjbGllbnQgcmVzdW1lIGZhaWxlZCAoJHt0aGlzLmNvbGxlY3Rpb25OYW1lfSAke3RoaXMucXVlcnl9KSAoJHt0aGlzLndhdGNoSWR9KWAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICAvLyB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbG9naW4gPSBhc3luYyAoXG4gICAgZW52SWQ/OiBzdHJpbmcsXG4gICAgcmVmcmVzaD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxJTG9naW5SZXN1bHQ+ID0+IHtcbiAgICB0aGlzLndhdGNoU3RhdHVzID0gV0FUQ0hfU1RBVFVTLkxPR0dJTkdJTjtcbiAgICBjb25zdCBsb2dpblJlc3VsdCA9IGF3YWl0IHRoaXMubG9naW4oZW52SWQsIHJlZnJlc2gpO1xuICAgIGlmICghdGhpcy5lbnZJZCkge1xuICAgICAgdGhpcy5lbnZJZCA9IGxvZ2luUmVzdWx0LmVudklkO1xuICAgIH1cbiAgICByZXR1cm4gbG9naW5SZXN1bHQ7XG4gIH07XG5cbiAgcHJpdmF0ZSBpbml0V2F0Y2ggPSBhc3luYyAoZm9yY2VSZWZyZXNoTG9naW4/OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHRoaXMuX2luaXRXYXRjaFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0V2F0Y2hQcm9taXNlO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRXYXRjaFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy53YXRjaFN0YXR1cyA9PT0gV0FUQ0hfU1RBVFVTLlBBVVNFRCkge1xuICAgICAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbcmVhbHRpbWVdIGluaXRXYXRjaCBjYW5jZWxsZWQgb24gcGF1c2UnKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZW52SWQgfSA9IGF3YWl0IHRoaXMuX2xvZ2luKHRoaXMuZW52SWQsIGZvcmNlUmVmcmVzaExvZ2luKTtcblxuICAgICAgICAvLyBpZiAoIXRoaXMuc2Vzc2lvbkluZm8pIHtcbiAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoYGNhbiBub3QgcmVidWlsZFdhdGNoIHdpdGhvdXQgYSBzdWNjZXNzZnVsIGluaXRXYXRjaCAobGFjayBvZiBzZXNzaW9uSW5mbylgKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKCh0aGlzLndhdGNoU3RhdHVzIGFzIFdBVENIX1NUQVRVUykgPT09IFdBVENIX1NUQVRVUy5QQVVTRUQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW3JlYWx0aW1lXSBpbml0V2F0Y2ggY2FuY2VsbGVkIG9uIHBhdXNlJyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuSU5JVElORztcblxuICAgICAgICBjb25zdCBpbml0V2F0Y2hNc2c6IElSZXF1ZXN0TWVzc2FnZUluaXRXYXRjaE1zZyA9IHtcbiAgICAgICAgICB3YXRjaElkOiB0aGlzLndhdGNoSWQsXG4gICAgICAgICAgcmVxdWVzdElkOiBnZW5SZXF1ZXN0SWQoKSxcbiAgICAgICAgICBtc2dUeXBlOiAnSU5JVF9XQVRDSCcsXG4gICAgICAgICAgbXNnRGF0YToge1xuICAgICAgICAgICAgZW52SWQsXG4gICAgICAgICAgICBjb2xsTmFtZTogdGhpcy5jb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgbGltaXQ6IHRoaXMubGltaXQsXG4gICAgICAgICAgICBvcmRlckJ5OiB0aGlzLm9yZGVyQnksXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpbml0RXZlbnRNc2cgPSBhd2FpdCB0aGlzLnNlbmQ8SVJlc3BvbnNlTWVzc2FnZUluaXRFdmVudE1zZz4oe1xuICAgICAgICAgIG1zZzogaW5pdFdhdGNoTXNnLFxuICAgICAgICAgIHdhaXRSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgICBza2lwT25NZXNzYWdlOiB0cnVlLFxuICAgICAgICAgIHRpbWVvdXQ6IERFRkFVTFRfSU5JVF9XQVRDSF9USU1FT1VULFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IGV2ZW50cywgY3VyckV2ZW50IH0gPSBpbml0RXZlbnRNc2cubXNnRGF0YTtcblxuICAgICAgICB0aGlzLnNlc3Npb25JbmZvID0ge1xuICAgICAgICAgIHF1ZXJ5SUQ6IGluaXRFdmVudE1zZy5tc2dEYXRhLnF1ZXJ5SUQsXG4gICAgICAgICAgY3VycmVudEV2ZW50SWQ6IGN1cnJFdmVudCAtIDEsXG4gICAgICAgICAgY3VycmVudERvY3M6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZJWDogaW4gaW5pdEV2ZW50IG1lc3NhZ2UsIGFsbCBldmVudHMgaGF2ZSBpZCAwLCB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCBjdXJyRXZlbnRcbiAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIGV2ZW50cykge1xuICAgICAgICAgICAgZS5JRCA9IGN1cnJFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTZXJ2ZXJFdmVudHMoaW5pdEV2ZW50TXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkID0gY3VyckV2ZW50O1xuICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFNuYXBzaG90KHtcbiAgICAgICAgICAgIGlkOiBjdXJyRXZlbnQsXG4gICAgICAgICAgICBkb2NDaGFuZ2VzOiBbXSxcbiAgICAgICAgICAgIGRvY3M6IFtdLFxuICAgICAgICAgICAgdHlwZTogJ2luaXQnLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMubGlzdGVuZXIub25DaGFuZ2Uoc25hcHNob3QpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVTZW5kQUNLKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbldhdGNoU3RhcnQodGhpcywgdGhpcy5zZXNzaW9uSW5mby5xdWVyeUlEKTtcbiAgICAgICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5BQ1RJVkU7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZVJldHJpZXMuSU5JVF9XQVRDSCA9IERFRkFVTFRfTUFYX0FVVE9fUkVUUllfT05fRVJST1I7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVXYXRjaEVzdGFibGlzaG1lbnRFcnJvcihlLCB7XG4gICAgICAgICAgb3BlcmF0aW9uTmFtZTogJ0lOSVRfV0FUQ0gnLFxuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5faW5pdFdhdGNoUHJvbWlzZTtcbiAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9pbml0V2F0Y2hQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUubG9nKGBbcmVhbHRpbWVdIGluaXRXYXRjaCAke3N1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnZmFpbCd9YCk7XG4gICAgLy8gfVxuICB9O1xuXG4gIHByaXZhdGUgcmVidWlsZFdhdGNoID0gYXN5bmMgKGZvcmNlUmVmcmVzaExvZ2luPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICh0aGlzLl9yZWJ1aWxkV2F0Y2hQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVidWlsZFdhdGNoUHJvbWlzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWJ1aWxkV2F0Y2hQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMud2F0Y2hTdGF0dXMgPT09IFdBVENIX1NUQVRVUy5QQVVTRUQpIHtcbiAgICAgICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW3JlYWx0aW1lXSByZWJ1aWxkV2F0Y2ggY2FuY2VsbGVkIG9uIHBhdXNlJyk7XG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBlbnZJZCB9ID0gYXdhaXQgdGhpcy5fbG9naW4odGhpcy5lbnZJZCwgZm9yY2VSZWZyZXNoTG9naW4pO1xuXG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uSW5mbykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCByZWJ1aWxkV2F0Y2ggd2l0aG91dCBhIHN1Y2Nlc3NmdWwgaW5pdFdhdGNoIChsYWNrIG9mIHNlc3Npb25JbmZvKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0aGlzLndhdGNoU3RhdHVzIGFzIFdBVENIX1NUQVRVUykgPT09IFdBVENIX1NUQVRVUy5QQVVTRUQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW3JlYWx0aW1lXSByZWJ1aWxkV2F0Y2ggY2FuY2VsbGVkIG9uIHBhdXNlJyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuUkVCVUlMRElORztcblxuICAgICAgICBjb25zdCByZWJ1aWxkV2F0Y2hNc2c6IElSZXF1ZXN0TWVzc2FnZVJlYnVpbGRXYXRjaE1zZyA9IHtcbiAgICAgICAgICB3YXRjaElkOiB0aGlzLndhdGNoSWQsXG4gICAgICAgICAgcmVxdWVzdElkOiBnZW5SZXF1ZXN0SWQoKSxcbiAgICAgICAgICBtc2dUeXBlOiAnUkVCVUlMRF9XQVRDSCcsXG4gICAgICAgICAgbXNnRGF0YToge1xuICAgICAgICAgICAgZW52SWQsXG4gICAgICAgICAgICBjb2xsTmFtZTogdGhpcy5jb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5SUQ6IHRoaXMuc2Vzc2lvbkluZm8ucXVlcnlJRCxcbiAgICAgICAgICAgIGV2ZW50SUQ6IHRoaXMuc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBuZXh0RXZlbnRNc2cgPSBhd2FpdCB0aGlzLnNlbmQ8SVJlc3BvbnNlTWVzc2FnZU5leHRFdmVudE1zZz4oe1xuICAgICAgICAgIG1zZzogcmVidWlsZFdhdGNoTXNnLFxuICAgICAgICAgIHdhaXRSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgICBza2lwT25NZXNzYWdlOiBmYWxzZSxcbiAgICAgICAgICB0aW1lb3V0OiBERUZBVUxUX1JFQlVJTERfV0FUQ0hfVElNRU9VVCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVTZXJ2ZXJFdmVudHMobmV4dEV2ZW50TXNnKTtcblxuICAgICAgICB0aGlzLndhdGNoU3RhdHVzID0gV0FUQ0hfU1RBVFVTLkFDVElWRTtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlUmV0cmllcy5SRUJVSUxEX1dBVENIID0gREVGQVVMVF9NQVhfQVVUT19SRVRSWV9PTl9FUlJPUjtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVdhdGNoRXN0YWJsaXNobWVudEVycm9yKGUsIHtcbiAgICAgICAgICBvcGVyYXRpb25OYW1lOiAnUkVCVUlMRF9XQVRDSCcsXG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9yZWJ1aWxkV2F0Y2hQcm9taXNlO1xuICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3JlYnVpbGRXYXRjaFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgY29uc29sZS5sb2coYFtyZWFsdGltZV0gcmVidWlsZFdhdGNoICR7c3VjY2VzcyA/ICdzdWNjZXNzJyA6ICdmYWlsJ31gKTtcbiAgICAvLyB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVXYXRjaEVzdGFibGlzaG1lbnRFcnJvciA9IGFzeW5jIChcbiAgICBlOiBhbnksXG4gICAgb3B0aW9uczogSUhhbmRsZVdhdGNoRXN0YWJsaXNobWVudEVycm9yT3B0aW9uc1xuICApID0+IHtcbiAgICBjb25zdCBpc0luaXRXYXRjaCA9IG9wdGlvbnMub3BlcmF0aW9uTmFtZSA9PT0gJ0lOSVRfV0FUQ0gnO1xuXG4gICAgY29uc3QgYWJvcnRXYXRjaCA9ICgpID0+IHtcbiAgICAgIC8vIG1vY2sgdGVtcCBjb21tZW50XG4gICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgZXJyQ29kZTogaXNJbml0V2F0Y2hcbiAgICAgICAgICA/IChFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfSU5JVF9XQVRDSF9GQUlMIGFzIHN0cmluZylcbiAgICAgICAgICA6IChFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfUkVCVUlMRF9XQVRDSF9GQUlMIGFzIHN0cmluZyksXG4gICAgICAgIGVyck1zZzogZSxcbiAgICAgIH0pKTtcbiAgICAgIG9wdGlvbnMucmVqZWN0KGUpO1xuICAgIH07XG5cbiAgICBjb25zdCByZXRyeSA9IChyZWZyZXNoTG9naW4/OiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAodGhpcy51c2VSZXRyeVRpY2tldChvcHRpb25zLm9wZXJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGlmIChpc0luaXRXYXRjaCkge1xuICAgICAgICAgIHRoaXMuX2luaXRXYXRjaFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgb3B0aW9ucy5yZXNvbHZlKHRoaXMuaW5pdFdhdGNoKHJlZnJlc2hMb2dpbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlYnVpbGRXYXRjaFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgb3B0aW9ucy5yZXNvbHZlKHRoaXMucmVidWlsZFdhdGNoKHJlZnJlc2hMb2dpbikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhYm9ydFdhdGNoKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlQ29tbW9uRXJyb3IoZSwge1xuICAgICAgb25TaWduRXJyb3I6ICgpID0+IHJldHJ5KHRydWUpLFxuICAgICAgb25UaW1lb3V0RXJyb3I6ICgpID0+IHJldHJ5KGZhbHNlKSxcbiAgICAgIG9uTm90UmV0cnlhYmxlRXJyb3I6IGFib3J0V2F0Y2gsXG4gICAgICBvbkNhbmNlbGxlZEVycm9yOiBvcHRpb25zLnJlamVjdCxcbiAgICAgIG9uVW5rbm93bkVycm9yOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb25XU0Rpc2Nvbm5lY3RlZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMub25jZVdTQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICByZXRyeSh0cnVlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmlzV1NDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgb25XU0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChERUZBVUxUX1dBSVRfVElNRV9PTl9VTktOT1dOX0VSUk9SKTtcbiAgICAgICAgICAgIGlmICh0aGlzLndhdGNoU3RhdHVzID09PSBXQVRDSF9TVEFUVVMuUEFVU0VEKSB7XG4gICAgICAgICAgICAgIC8vIGNhbmNlbFxuICAgICAgICAgICAgICBvcHRpb25zLnJlamVjdChuZXcgQ2FuY2VsbGVkRXJyb3IoYCR7b3B0aW9ucy5vcGVyYXRpb25OYW1lfSBjYW5jZWxsZWQgZHVlIHRvIHBhdXNlIGFmdGVyIHVua25vd25FcnJvcmApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNXU0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgIGF3YWl0IG9uV1NEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHJ5KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIGVycm9yIHdoaWxlIGhhbmRsaW5nIGVycm9yLCBpbiBvcmRlciB0byBwcm92aWRlIG1heGltdW0gZWZmb3J0IG9uIFNFQU1JTkdMRVNTIEZBVUxUIFRPTEVSQU5DRSwganVzdCByZXRyeVxuICAgICAgICAgIHJldHJ5KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgY2xvc2VXYXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBxdWVyeUlkID0gdGhpcy5zZXNzaW9uSW5mbyA/IHRoaXMuc2Vzc2lvbkluZm8ucXVlcnlJRCA6ICcnO1xuXG4gICAgaWYgKHRoaXMud2F0Y2hTdGF0dXMgIT09IFdBVENIX1NUQVRVUy5BQ1RJVkUpIHtcbiAgICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuQ0xPU0VEO1xuICAgICAgdGhpcy5vbldhdGNoQ2xvc2UodGhpcywgcXVlcnlJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuQ0xPU0lORztcblxuICAgICAgY29uc3QgY2xvc2VXYXRjaE1zZzogSVJlcXVlc3RNZXNzYWdlQ2xvc2VXYXRjaE1zZyA9IHtcbiAgICAgICAgd2F0Y2hJZDogdGhpcy53YXRjaElkLFxuICAgICAgICByZXF1ZXN0SWQ6IGdlblJlcXVlc3RJZCgpLFxuICAgICAgICBtc2dUeXBlOiAnQ0xPU0VfV0FUQ0gnLFxuICAgICAgICBtc2dEYXRhOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgbXNnOiBjbG9zZVdhdGNoTXNnLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2Vzc2lvbkluZm8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLndhdGNoU3RhdHVzID0gV0FUQ0hfU1RBVFVTLkNMT1NFRDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgZXJyQ29kZTogRVJSX0NPREUuU0RLX0RBVEFCQVNFX1JFQUxUSU1FX0xJU1RFTkVSX0NMT1NFX1dBVENIX0ZBSUwgYXMgc3RyaW5nLFxuICAgICAgICBlcnJNc2c6IGUsXG4gICAgICB9KSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMub25XYXRjaENsb3NlKHRoaXMsIHF1ZXJ5SWQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHNjaGVkdWxlU2VuZEFDSyA9ICgpID0+IHtcbiAgICB0aGlzLmNsZWFyQUNLU2NoZWR1bGUoKTtcblxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBjaGVjayBzdGF0dXMgYWZ0ZXIgdGltZW91dFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLl9hY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl93YWl0RXhwZWN0ZWRUaW1lb3V0SWQpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVNlbmRBQ0soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VuZEFDSygpO1xuICAgICAgfVxuICAgIH0sIERFRkFVTFRfU0VORF9BQ0tfREVCT1VOQ0VfVElNRU9VVCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBjbGVhckFDS1NjaGVkdWxlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLl9hY2tUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9hY2tUaW1lb3V0SWQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHNlbmRBQ0sgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLndhdGNoU3RhdHVzICE9PSBXQVRDSF9TVEFUVVMuQUNUSVZFKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVTZW5kQUNLKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlc3Npb25JbmZvKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3JlYWx0aW1lIGxpc3RlbmVyXSBjYW4gbm90IHNlbmQgYWNrIHdpdGhvdXQgYSBzdWNjZXNzZnVsIGluaXRXYXRjaCAobGFjayBvZiBzZXNzaW9uSW5mbyknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2tNc2c6IElSZXF1ZXN0TWVzc2FnZUNoZWNrTGFzdE1zZyA9IHtcbiAgICAgICAgd2F0Y2hJZDogdGhpcy53YXRjaElkLFxuICAgICAgICByZXF1ZXN0SWQ6IGdlblJlcXVlc3RJZCgpLFxuICAgICAgICBtc2dUeXBlOiAnQ0hFQ0tfTEFTVCcsXG4gICAgICAgIG1zZ0RhdGE6IHtcbiAgICAgICAgICBxdWVyeUlEOiB0aGlzLnNlc3Npb25JbmZvLnF1ZXJ5SUQsXG4gICAgICAgICAgZXZlbnRJRDogdGhpcy5zZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZCxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgIG1zZzogYWNrTXNnLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2NoZWR1bGVTZW5kQUNLKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVE9ETzogcmVmYWN0b3JcbiAgICAgIGlmIChpc1JlYWx0aW1lRXJyb3JNZXNzYWdlRXJyb3IoZSkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZS5wYXlsb2FkO1xuICAgICAgICBzd2l0Y2ggKG1zZy5tc2dEYXRhLmNvZGUpIHtcbiAgICAgICAgICAvLyBzaWduYXR1cmUgZXJyb3IgLT4gcmV0cnkgd2l0aCByZWZyZXNoZWQgc2lnbmF0dXJlXG4gICAgICAgICAgY2FzZSAnQ0hFQ0tfTE9HSU5fRkFJTEVEJzpcbiAgICAgICAgICBjYXNlICdTSUdOX0VYUElSRURfRVJST1InOlxuICAgICAgICAgIGNhc2UgJ1NJR05fSU5WQUxJRF9FUlJPUic6XG4gICAgICAgICAgY2FzZSAnU0lHTl9QQVJBTV9JTlZBTElEJzoge1xuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkV2F0Y2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3RoZXIgLT4gdGhyb3dcbiAgICAgICAgICBjYXNlICdRVUVSWUlEX0lOVkFMSURfRVJST1InOlxuICAgICAgICAgIGNhc2UgJ1NZU19FUlInOlxuICAgICAgICAgIGNhc2UgJ0lOVkFMSUlEX0VOVic6XG4gICAgICAgICAgY2FzZSAnQ09MTEVDVElPTl9QRVJNSVNTSU9OX0RFTklFRCc6IHtcbiAgICAgICAgICAgIC8vIG11c3QgdGhyb3dcbiAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IENsb3VkU0RLRXJyb3Ioe1xuICAgICAgICAgICAgICBlcnJDb2RlOiBFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfQ0hFQ0tfTEFTVF9GQUlMIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgZXJyTXNnOiBtc2cubXNnRGF0YS5jb2RlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWF5YmUgcmV0cnlhYmxlXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZVJldHJpZXMuQ0hFQ0tfTEFTVFxuICAgICAgICAmJiB0aGlzLl9hdmFpbGFibGVSZXRyaWVzLkNIRUNLX0xBU1QgPiAwXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlUmV0cmllcy5DSEVDS19MQVNULS07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVTZW5kQUNLKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgICBlcnJDb2RlOiBFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfQ0hFQ0tfTEFTVF9GQUlMIGFzIHN0cmluZyxcbiAgICAgICAgICBlcnJNc2c6IGUsXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVDb21tb25FcnJvciA9IChcbiAgICBlOiBhbnksXG4gICAgb3B0aW9uczogSUhhbmRsZUNvbW1vbkVycm9yT3B0aW9uc1xuICApOiB2b2lkID0+IHtcbiAgICBpZiAoaXNSZWFsdGltZUVycm9yTWVzc2FnZUVycm9yKGUpKSB7XG4gICAgICBjb25zdCBtc2cgPSBlLnBheWxvYWQ7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2dEYXRhLmNvZGUpIHtcbiAgICAgICAgLy8gc2lnbmF0dXJlIGVycm9yIC0+IHJldHJ5IHdpdGggcmVmcmVzaGVkIHNpZ25hdHVyZVxuICAgICAgICBjYXNlICdDSEVDS19MT0dJTl9GQUlMRUQnOlxuICAgICAgICBjYXNlICdTSUdOX0VYUElSRURfRVJST1InOlxuICAgICAgICBjYXNlICdTSUdOX0lOVkFMSURfRVJST1InOlxuICAgICAgICBjYXNlICdTSUdOX1BBUkFNX0lOVkFMSUQnOiB7XG4gICAgICAgICAgb3B0aW9ucy5vblNpZ25FcnJvcihlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90LXJldHJ5YWJsZSBlcnJvciAtPiB0aHJvd1xuICAgICAgICBjYXNlICdRVUVSWUlEX0lOVkFMSURfRVJST1InOlxuICAgICAgICBjYXNlICdTWVNfRVJSJzpcbiAgICAgICAgY2FzZSAnSU5WQUxJSURfRU5WJzpcbiAgICAgICAgY2FzZSAnQ09MTEVDVElPTl9QRVJNSVNTSU9OX0RFTklFRCc6IHtcbiAgICAgICAgICBvcHRpb25zLm9uTm90UmV0cnlhYmxlRXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBvcHRpb25zLm9uTm90UmV0cnlhYmxlRXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RpbWVvdXRFcnJvcihlKSkge1xuICAgICAgLy8gdGltZW91dCBlcnJvclxuICAgICAgb3B0aW9ucy5vblRpbWVvdXRFcnJvcihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGlzQ2FuY2VsbGVkRXJyb3IoZSkpIHtcbiAgICAgIC8vIGNhbmNlbGxlZCBlcnJvclxuICAgICAgb3B0aW9ucy5vbkNhbmNlbGxlZEVycm9yKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVua25vd24gZXJyb3JcbiAgICBvcHRpb25zLm9uVW5rbm93bkVycm9yKGUpO1xuICB9O1xuXG4gIC8vIGNyZWRpdCBhIHJldHJ5IGNoYW5jZSBmcm9tIGF2YWlsYWJsZVJldHJpZXNcbiAgcHJpdmF0ZSB1c2VSZXRyeVRpY2tldChvcGVyYXRpb25OYW1lOiBJUmVxdWVzdE1zZ1R5cGUpOiBib29sZWFuIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9hdmFpbGFibGVSZXRyaWVzW29wZXJhdGlvbk5hbWVdXG4gICAgICAmJiB0aGlzLl9hdmFpbGFibGVSZXRyaWVzW29wZXJhdGlvbk5hbWVdISA+IDBcbiAgICApIHtcbiAgICAgIHRoaXMuX2F2YWlsYWJsZVJldHJpZXNbb3BlcmF0aW9uTmFtZV0hLS07XG5cbiAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgY29uc29sZS5sb2coYFtyZWFsdGltZV0gJHtvcGVyYXRpb25OYW1lfSB1c2UgYSByZXRyeSB0aWNrZXQsIG5vdyBvbmx5ICR7dGhpcy5fYXZhaWxhYmxlUmV0cmllc1tvcGVyYXRpb25OYW1lXX0gcmV0cnkgbGVmdGApO1xuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTZXJ2ZXJFdmVudHMobXNnOiBJUmVzcG9uc2VNZXNzYWdlSW5pdEV2ZW50TXNnIHwgSVJlc3BvbnNlTWVzc2FnZU5leHRFdmVudE1zZykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnNjaGVkdWxlU2VuZEFDSygpO1xuICAgICAgYXdhaXQgdGhpcy5faGFuZGxlU2VydmVyRXZlbnRzKG1zZyk7XG4gICAgICB0aGlzLl9wb3N0SGFuZGxlU2VydmVyRXZlbnRzVmFsaWRpdHlDaGVjayhtc2cpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgLy8gVE9ETzogcmVwb3J0XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IGhhbmRsZSBzZXJ2ZXIgZXZlbnRzIGZhaWxlZCB3aXRoIGVycm9yOiAnLFxuICAgICAgICBlXG4gICAgICApO1xuXG4gICAgICAvLyB3cml0ZVRvRmlsZShcbiAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgLy8gICBgW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IGhhbmRsZSBzZXJ2ZXIgZXZlbnRzIGZhaWxlZCB3aXRoIGVycm9yOiAgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIC8vICAgICBPYmplY3QuYXNzaWduKHt9LCBlLCB7XG4gICAgICAvLyAgICAgICByZXF1ZXN0SWQ6IG1zZy5yZXF1ZXN0SWQsXG4gICAgICAvLyAgICAgICB3YXRjaElkOiBtc2cud2F0Y2hJZFxuICAgICAgLy8gICAgIH0pXG4gICAgICAvLyAgICl9IFxcbmBcbiAgICAgIC8vIClcbiAgICAgIC8vIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9oYW5kbGVTZXJ2ZXJFdmVudHMobXNnOiBJUmVzcG9uc2VNZXNzYWdlSW5pdEV2ZW50TXNnIHwgSVJlc3BvbnNlTWVzc2FnZU5leHRFdmVudE1zZykge1xuICAgIGNvbnN0IHsgcmVxdWVzdElkIH0gPSBtc2c7XG5cbiAgICBjb25zdCB7IGV2ZW50cyB9ID0gbXNnLm1zZ0RhdGE7XG4gICAgY29uc3QgeyBtc2dUeXBlIH0gPSBtc2c7XG5cbiAgICBpZiAoIWV2ZW50cy5sZW5ndGggfHwgIXRoaXMuc2Vzc2lvbkluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNlc3Npb25JbmZvIH0gPSB0aGlzO1xuXG4gICAgbGV0IGFsbENoYW5nZUV2ZW50czogSVNpbmdsZURCRXZlbnRbXTtcbiAgICB0cnkge1xuICAgICAgYWxsQ2hhbmdlRXZlbnRzID0gZXZlbnRzLm1hcChnZXRQdWJsaWNFdmVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihuZXcgQ2xvdWRTREtFcnJvcih7XG4gICAgICAgIGVyckNvZGU6IEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9SRUNFSVZFX0lOVkFMSURfU0VSVkVSX0RBVEEgYXMgc3RyaW5nLFxuICAgICAgICBlcnJNc2c6IGUsXG4gICAgICB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWdncmVnYXRlIGRvY3NcbiAgICBsZXQgZG9jcyA9IFsuLi5zZXNzaW9uSW5mby5jdXJyZW50RG9jc107XG4gICAgbGV0IGluaXRFbmNvdW50ZXJlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhbGxDaGFuZ2VFdmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5nZSA9IGFsbENoYW5nZUV2ZW50c1tpXTtcblxuICAgICAgaWYgKHNlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkID49IGNoYW5nZS5pZCkge1xuICAgICAgICBpZiAoIWFsbENoYW5nZUV2ZW50c1tpIC0gMV0gfHwgY2hhbmdlLmlkID4gYWxsQ2hhbmdlRXZlbnRzW2kgLSAxXS5pZCkge1xuICAgICAgICAgIC8vIGR1cGxpY2F0ZSBldmVudCwgZHJvcGFibGVcbiAgICAgICAgICAvLyBUT0RPOiByZXBvcnRcbiAgICAgICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtyZWFsdGltZV0gZHVwbGljYXRlIGV2ZW50IHJlY2VpdmVkLCBjdXIgJHtzZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZH0gYnV0IGdvdCAke2NoYW5nZS5pZH1gKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWxsQ2hhbmdlRXZlbnRzIHNob3VsZCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIGV2ZW50SWQsIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbnMsIG11c3QgcmVwb3J0IGEgbm9uLWZhdGFsIGVycm9yXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW3JlYWx0aW1lIGxpc3RlbmVyXSBzZXJ2ZXIgbm9uLWZhdGFsIGVycm9yOiBldmVudHMgb3V0IG9mIG9yZGVyICh0aGUgbGF0dGVyIGV2ZW50J3MgaWQgaXMgc21hbGxlciB0aGFuIHRoYXQgb2YgdGhlIGZvcm1lcikgKHJlcXVlc3RJZCAke3JlcXVlc3RJZH0pYCk7XG5cbiAgICAgICAgICAvLyB3cml0ZVRvRmlsZShcbiAgICAgICAgICAvLyAgIFwid3NlcnJvci50eHRcIixcbiAgICAgICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIHNlcnZlciBub24tZmF0YWwgZXJyb3I6IGV2ZW50cyBvdXQgb2Ygb3JkZXIgKHRoZSBsYXR0ZXIgZXZlbnQncyBpZCBpcyBzbWFsbGVyIHRoYW4gdGhhdCBvZiB0aGUgZm9ybWVyKSAgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAvLyAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAvLyAgICAgICB7fSxcbiAgICAgICAgICAvLyAgICAgICB7XG4gICAgICAgICAgLy8gICAgICAgICByZXF1ZXN0SWQ6IG1zZy5yZXF1ZXN0SWQsXG4gICAgICAgICAgLy8gICAgICAgICB3YXRjaElkOiBtc2cud2F0Y2hJZFxuICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAvLyAgICAgKVxuICAgICAgICAgIC8vICAgKX0gXFxuYFxuICAgICAgICAgIC8vIClcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWQgPT09IGNoYW5nZS5pZCAtIDEpIHtcbiAgICAgICAgLy8gY29ycmVjdCBzZXF1ZW5jZVxuICAgICAgICAvLyBmaXJzdCBoYW5kbGUgZGF0YVR5cGUgdGhlbiBxdWV1ZVR5cGU6XG4gICAgICAgIC8vIDEuIGRhdGFUeXBlOiB3ZSBPTkxZIHBvcHVsYXRlIGNoYW5nZS5kb2MgaWYgbmVjY2Vzc2FyeVxuICAgICAgICAvLyAyLiBxdWV1ZVR5cGU6IHdlIGJ1aWxkIHRoZSBkYXRhIHNuYXBzaG90XG5cbiAgICAgICAgc3dpdGNoIChjaGFuZ2UuZGF0YVR5cGUpIHtcbiAgICAgICAgICBjYXNlICd1cGRhdGUnOiB7XG4gICAgICAgICAgICAvLyBvbmx5IG5lZWQgdG8gcG9wdWxhdGUgY2hhbmdlLmRvYyB3aGVuIGl0IGlzIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKCFjaGFuZ2UuZG9jKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlLnF1ZXVlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVxdWV1ZSc6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsRG9jID0gZG9jcy5maW5kKGRvYyA9PiBkb2MuX2lkID09PSBjaGFuZ2UuZG9jSWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcGFydGlhbCB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY2xvbmVEZWVwKGxvY2FsRG9jKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnVwZGF0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkUGF0aCBpbiBjaGFuZ2UudXBkYXRlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KGRvYywgZmllbGRQYXRoLCBjaGFuZ2UudXBkYXRlZEZpZWxkc1tmaWVsZFBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlbW92ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkUGF0aCBvZiBjaGFuZ2UucmVtb3ZlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5zZXQoZG9jLCBmaWVsZFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kb2MgPSBkb2M7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlcG9ydFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgdXBkYXRlIGRhdGFUeXBlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgICAgICAgICAgICAgICAvLyAgIFwid3NlcnJvci50eHRcIixcbiAgICAgICAgICAgICAgICAgICAgLy8gICBgW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgc2VydmVyIGVycm9yOiB1bmV4cGVjdGVkIHVwZGF0ZSBkYXRhVHlwZSBldmVudCB3aGVyZSBubyBkb2MgaXMgYXNzb2NpYXRlZC4gICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJlcXVlc3RJZDogbXNnLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB3YXRjaElkOiBtc2cud2F0Y2hJZFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8vICAgKX0gXFxuYFxuICAgICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5xdWV1ZSc6IHtcbiAgICAgICAgICAgICAgICAgIC8vIGRvYyBpcyBwcm92aWRlZCBieSBzZXJ2ZXIsIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyXG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgQ2xvdWRTREtFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVyckNvZGU6IEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9VTkVYUEVDVEVEX0ZBVEFMX0VSUk9SIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnOiBgSGFuZGxlU2VydmVyRXZlbnRzOiBmdWxsIGRvYyBpcyBub3QgcHJvdmlkZWQgd2l0aCBkYXRhVHlwZT1cInVwZGF0ZVwiIGFuZCBxdWV1ZVR5cGU9XCJlbnF1ZXVlXCIgKHJlcXVlc3RJZCAke21zZy5yZXF1ZXN0SWR9KWAsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmVwbGFjZSc6IHtcbiAgICAgICAgICAgIC8vIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGlmICghY2hhbmdlLmRvYykge1xuICAgICAgICAgICAgICAvLyBkb2MgaXMgcHJvdmlkZWQgYnkgc2VydmVyLCB0aGlzIHNob3VsZCBuZXZlciBvY2N1clxuICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgQ2xvdWRTREtFcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyQ29kZTogRVJSX0NPREUuU0RLX0RBVEFCQVNFX1JFQUxUSU1FX0xJU1RFTkVSX1VORVhQRUNURURfRkFUQUxfRVJST1IgYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIGVyck1zZzogYEhhbmRsZVNlcnZlckV2ZW50czogZnVsbCBkb2MgaXMgbm90IHByb3ZpZGVkIHdpdGggZGF0YVR5cGU9XCJyZXBsYWNlXCIgKHJlcXVlc3RJZCAke21zZy5yZXF1ZXN0SWR9KWAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyZW1vdmUnOiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBkb2NzLmZpbmQoZG9jID0+IGRvYy5faWQgPT09IGNoYW5nZS5kb2NJZCk7XG4gICAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAgIGNoYW5nZS5kb2MgPSBkb2M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUT0RPIHJlcG9ydFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgcmVtb3ZlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLicpO1xuXG4gICAgICAgICAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgICAgICAgICAvLyAgIFwid3NlcnJvci50eHRcIixcbiAgICAgICAgICAgICAgLy8gICBgW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgc2VydmVyIGVycm9yOiB1bmV4cGVjdGVkIHJlbW92ZSBldmVudCB3aGVyZSBubyBkb2MgaXMgYXNzb2NpYXRlZC4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgLy8gICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIC8vICAgICAgIHt9LFxuICAgICAgICAgICAgICAvLyAgICAgICB7XG4gICAgICAgICAgICAgIC8vICAgICAgICAgcmVxdWVzdElkOiBtc2cucmVxdWVzdElkLFxuICAgICAgICAgICAgICAvLyAgICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gICAgIClcbiAgICAgICAgICAgICAgLy8gICApfSBcXG5gXG4gICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsaW1pdCc6IHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlLmRvYykge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZS5xdWV1ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkZXF1ZXVlJzoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZG9jID0gZG9jcy5maW5kKGRvYyA9PiBkb2MuX2lkID09PSBjaGFuZ2UuZG9jSWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZG9jID0gZG9jO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgc2VydmVyIGVycm9yOiB1bmV4cGVjdGVkIGxpbWl0IGRhdGFUeXBlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2VucXVldWUnOiB7XG4gICAgICAgICAgICAgICAgICAvLyBkb2MgaXMgcHJvdmlkZWQgYnkgc2VydmVyLCB0aGlzIHNob3VsZCBuZXZlciBvY2N1clxuICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IENsb3VkU0RLRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBlcnJDb2RlOiBFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfVU5FWFBFQ1RFRF9GQVRBTF9FUlJPUiBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGVyck1zZzogYEhhbmRsZVNlcnZlckV2ZW50czogZnVsbCBkb2MgaXMgbm90IHByb3ZpZGVkIHdpdGggZGF0YVR5cGU9XCJsaW1pdFwiIGFuZCBxdWV1ZVR5cGU9XCJlbnF1ZXVlXCIgKHJlcXVlc3RJZCAke21zZy5yZXF1ZXN0SWR9KWAsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNoYW5nZS5xdWV1ZVR5cGUpIHtcbiAgICAgICAgICBjYXNlICdpbml0Jzoge1xuICAgICAgICAgICAgaWYgKCFpbml0RW5jb3VudGVyZWQpIHtcbiAgICAgICAgICAgICAgaW5pdEVuY291bnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZG9jcyA9IFtjaGFuZ2UuZG9jXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvY3MucHVzaChjaGFuZ2UuZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdlbnF1ZXVlJzoge1xuICAgICAgICAgICAgZG9jcy5wdXNoKGNoYW5nZS5kb2MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2RlcXVldWUnOiB7XG4gICAgICAgICAgICBjb25zdCBpbmQgPSBkb2NzLmZpbmRJbmRleChkb2MgPT4gZG9jLl9pZCA9PT0gY2hhbmdlLmRvY0lkKTtcbiAgICAgICAgICAgIGlmIChpbmQgPiAtMSkge1xuICAgICAgICAgICAgICBkb2NzLnNwbGljZShpbmQsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyByZXBvcnRcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgc2VydmVyIGVycm9yOiB1bmV4cGVjdGVkIGRlcXVldWUgZXZlbnQgd2hlcmUgbm8gZG9jIGlzIGFzc29jaWF0ZWQuJyk7XG5cbiAgICAgICAgICAgICAgLy8gd3JpdGVUb0ZpbGUoXG4gICAgICAgICAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgICAgICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgZGVxdWV1ZSBldmVudCB3aGVyZSBubyBkb2MgaXMgYXNzb2NpYXRlZC4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgLy8gICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIC8vICAgICAgIHt9LFxuICAgICAgICAgICAgICAvLyAgICAgICB7XG4gICAgICAgICAgICAgIC8vICAgICAgICAgcmVxdWVzdElkOiBtc2cucmVxdWVzdElkLFxuICAgICAgICAgICAgICAvLyAgICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gICAgIClcbiAgICAgICAgICAgICAgLy8gICApfSBcXG5gXG4gICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICd1cGRhdGUnOiB7XG4gICAgICAgICAgICAvLyB3cml0ZVRvRmlsZShcbiAgICAgICAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgICAgICAgLy8gICBgW3JlYWx0aW1lIGxpc3RlbmVyXSBkb2NzICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAvLyAgICAgZG9jc1xuICAgICAgICAgICAgLy8gICApfSBjaGFuZ2UgZG9jICR7SlNPTi5zdHJpbmdpZnkoY2hhbmdlKX0gXFxuYFxuICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgY29uc3QgaW5kID0gZG9jcy5maW5kSW5kZXgoZG9jID0+IGRvYy5faWQgPT09IGNoYW5nZS5kb2NJZCk7XG4gICAgICAgICAgICBpZiAoaW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgZG9jc1tpbmRdID0gY2hhbmdlLmRvYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gcmVwb3J0XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIHNlcnZlciBlcnJvcjogdW5leHBlY3RlZCBxdWV1ZVR5cGUgdXBkYXRlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLicpO1xuXG4gICAgICAgICAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgICAgICAgICAvLyAgIFwid3NlcnJvci50eHRcIixcbiAgICAgICAgICAgICAgLy8gICBgW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgc2VydmVyIGVycm9yOiB1bmV4cGVjdGVkIHF1ZXVlVHlwZSB1cGRhdGUgZXZlbnQgd2hlcmUgbm8gZG9jIGlzIGFzc29jaWF0ZWQuICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIC8vICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAvLyAgICAgICB7fSxcbiAgICAgICAgICAgICAgLy8gICAgICAge1xuICAgICAgICAgICAgICAvLyAgICAgICAgIHJlcXVlc3RJZDogbXNnLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgLy8gICAgICAgICB3YXRjaElkOiBtc2cud2F0Y2hJZFxuICAgICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAgIC8vICAgICApXG4gICAgICAgICAgICAgIC8vICAgKX0gXFxuYFxuICAgICAgICAgICAgICAvLyApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaSA9PT0gbGVuIC0gMVxuICAgICAgICAgIHx8IChhbGxDaGFuZ2VFdmVudHNbaSArIDFdICYmIGFsbENoYW5nZUV2ZW50c1tpICsgMV0uaWQgIT09IGNoYW5nZS5pZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gYSBzaGFsbG93IHNsaWNlIGNyZWF0ZXMgYSBzaGFsbG93IHNuYXBzaG90XG4gICAgICAgICAgY29uc3QgZG9jc1NuYXBzaG90ID0gWy4uLmRvY3NdO1xuXG4gICAgICAgICAgLy8gd2Ugc2xpY2UgZmlyc3QgY2F1c2UnIGlmIHRoZXJlJ3JlIGFsbENoYW5nZUV2ZW50cyB0aGF0IGFyZSBvZiB0aGUgc2FtZSBpZCBhZnRlciB0aGlzIGNoYW5nZSwgd2UgZG9uJ3Qgd2FudCB0byBpbnZvbHZlIGl0IGZvciBpdCBpcyB1bmV4cGVjdGVkIGludmFsaWQgb3JkZXJcbiAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gYWxsQ2hhbmdlRXZlbnRzXG4gICAgICAgICAgICAuc2xpY2UoMCwgaSArIDEpXG4gICAgICAgICAgICAuZmlsdGVyKGMgPT4gYy5pZCA9PT0gY2hhbmdlLmlkKTtcblxuICAgICAgICAgIC8vIGFsbCBjaGFuZ2VzIG9mIHRoaXMgZXZlbnQgaGFzIGJlZW4gaGFuZGxlLCB3ZSBjb3VsZCBkaXNwYXRjaCB0aGUgZXZlbnQgbm93XG4gICAgICAgICAgdGhpcy5zZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZCA9IGNoYW5nZS5pZDtcbiAgICAgICAgICB0aGlzLnNlc3Npb25JbmZvLmN1cnJlbnREb2NzID0gZG9jcztcblxuICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFNuYXBzaG90KHtcbiAgICAgICAgICAgIGlkOiBjaGFuZ2UuaWQsXG4gICAgICAgICAgICBkb2NDaGFuZ2VzLFxuICAgICAgICAgICAgZG9jczogZG9jc1NuYXBzaG90LFxuICAgICAgICAgICAgbXNnVHlwZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFJlcG9ydGVyLnN1cnJvdW5kVGhpcmRCeVRyeUNhdGNoKCgpID0+XG4gICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkNoYW5nZShzbmFwc2hvdCk7XG4gICAgICAgICAgLy8gKSgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG91dC1vZi1vcmRlciBldmVudFxuICAgICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgICAgLy8gVE9ETzogcmVwb3J0XG4gICAgICAgIGNvbnNvbGUud2FybihgW3JlYWx0aW1lIGxpc3RlbmVyXSBldmVudCByZWNlaXZlZCBpcyBvdXQgb2Ygb3JkZXIsIGN1ciAke3RoaXMuc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWR9IGJ1dCBnb3QgJHtjaGFuZ2UuaWR9YCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcmVidWlsZCB3YXRjaFxuICAgICAgICBhd2FpdCB0aGlzLnJlYnVpbGRXYXRjaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfcG9zdEhhbmRsZVNlcnZlckV2ZW50c1ZhbGlkaXR5Q2hlY2sobXNnOiBJUmVzcG9uc2VNZXNzYWdlSW5pdEV2ZW50TXNnIHwgSVJlc3BvbnNlTWVzc2FnZU5leHRFdmVudE1zZykge1xuICAgIGlmICghdGhpcy5zZXNzaW9uSW5mbykge1xuICAgICAgY29uc29sZS5lcnJvcignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IHNlc3Npb25JbmZvIGxvc3QgYWZ0ZXIgc2VydmVyIGV2ZW50IGhhbmRsaW5nLCB0aGlzIHNob3VsZCBuZXZlciBvY2N1cicpO1xuXG4gICAgICAvLyB3cml0ZVRvRmlsZShcbiAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgLy8gICBgW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IHNlc3Npb25JbmZvIGxvc3QgYWZ0ZXIgc2VydmVyIGV2ZW50IGhhbmRsaW5nLCB0aGlzIHNob3VsZCBuZXZlciBvY2N1ciAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgLy8gICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAvLyAgICAgICB7fSxcbiAgICAgIC8vICAgICAgIHtcbiAgICAgIC8vICAgICAgICAgcmVxdWVzdElkOiBtc2cucmVxdWVzdElkLFxuICAgICAgLy8gICAgICAgICB3YXRjaElkOiBtc2cud2F0Y2hJZFxuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gICAgIClcbiAgICAgIC8vICAgKX0gXFxuYFxuICAgICAgLy8gKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMuc2Vzc2lvbkluZm8uZXhwZWN0RXZlbnRJZFxuICAgICAgJiYgdGhpcy5zZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZCA+PSB0aGlzLnNlc3Npb25JbmZvLmV4cGVjdEV2ZW50SWRcbiAgICApIHtcbiAgICAgIHRoaXMuY2xlYXJXYWl0RXhwZWN0ZWRFdmVudCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkIDwgbXNnLm1zZ0RhdGEuY3VyckV2ZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIGVycm9yOiBjbGllbnQgZXZlbnRJZCBkb2VzIG5vdCBtYXRjaCB3aXRoIHNlcnZlciBldmVudCBpZCBhZnRlciBzZXJ2ZXIgZXZlbnQgaGFuZGxpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNsZWFyV2FpdEV4cGVjdGVkRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX3dhaXRFeHBlY3RlZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3dhaXRFeHBlY3RlZFRpbWVvdXRJZCk7XG4gICAgICB0aGlzLl93YWl0RXhwZWN0ZWRUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0V2ZW50KGV2ZW50OiBJREJFdmVudCk6IElTaW5nbGVEQkV2ZW50IHtcbiAgY29uc3QgZTogSVNpbmdsZURCRXZlbnQgPSB7XG4gICAgaWQ6IGV2ZW50LklELFxuICAgIGRhdGFUeXBlOiBldmVudC5EYXRhVHlwZSxcbiAgICBxdWV1ZVR5cGU6IGV2ZW50LlF1ZXVlVHlwZSxcbiAgICBkb2NJZDogZXZlbnQuRG9jSUQsXG4gICAgZG9jOiBldmVudC5Eb2MgJiYgZXZlbnQuRG9jICE9PSAne30nID8gSlNPTi5wYXJzZShldmVudC5Eb2MpIDogdW5kZWZpbmVkLFxuICB9O1xuXG4gIGlmIChldmVudC5EYXRhVHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGV2ZW50LlVwZGF0ZWRGaWVsZHMpIHtcbiAgICAgIGUudXBkYXRlZEZpZWxkcyA9IEpTT04ucGFyc2UoZXZlbnQuVXBkYXRlZEZpZWxkcyk7XG4gICAgfVxuICAgIC8vIFRPRE86IHdhaXQgZm9yIHRjYiB0byBjaGFuZ2UgcmVtb3ZlZEZpZWxkcyB0byBSZW1vdmVkRmllbGRzXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChldmVudC5yZW1vdmVkRmllbGRzIHx8IGV2ZW50LlJlbW92ZWRGaWVsZHMpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC8vIGUucmVtb3ZlZEZpZWxkcyA9IGV2ZW50LnJlbW92ZWRGaWVsZHNcbiAgICAgIC8vICAgPyBKU09OLnBhcnNlKGV2ZW50LnJlbW92ZWRGaWVsZHMpXG4gICAgICAvLyAgIDogSlNPTi5wYXJzZShldmVudC5SZW1vdmVkRmllbGRzKVxuICAgICAgZS5yZW1vdmVkRmllbGRzID0gSlNPTi5wYXJzZShldmVudC5yZW1vdmVkRmllbGRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZTtcbn1cbiJdfQ==