"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualWebSocketClient = void 0;
var lodash_set_1 = __importDefault(require("lodash.set"));
var lodash_unset_1 = __importDefault(require("lodash.unset"));
var lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
var message_1 = require("./message");
var listener_1 = require("./listener");
var snapshot_1 = require("./snapshot");
var error_1 = require("./error");
var utils_1 = require("./utils");
var WATCH_STATUS;
(function (WATCH_STATUS) {
    WATCH_STATUS["LOGGINGIN"] = "LOGGINGIN";
    WATCH_STATUS["INITING"] = "INITING";
    WATCH_STATUS["REBUILDING"] = "REBUILDING";
    WATCH_STATUS["ACTIVE"] = "ACTIVE";
    WATCH_STATUS["ERRORED"] = "ERRORED";
    WATCH_STATUS["CLOSING"] = "CLOSING";
    WATCH_STATUS["CLOSED"] = "CLOSED";
    WATCH_STATUS["PAUSED"] = "PAUSED";
    WATCH_STATUS["RESUMING"] = "RESUMING";
})(WATCH_STATUS || (WATCH_STATUS = {}));
var DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR = 100;
var DEFAULT_MAX_AUTO_RETRY_ON_ERROR = 2;
var DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR = 2;
var DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT = 10 * 1000;
var DEFAULT_INIT_WATCH_TIMEOUT = 10 * 1000;
var DEFAULT_REBUILD_WATCH_TIMEOUT = 10 * 1000;
var VirtualWebSocketClient = (function () {
    function VirtualWebSocketClient(options) {
        var _this = this;
        this.watchStatus = WATCH_STATUS.INITING;
        this._login = function (envId, refresh) { return __awaiter(_this, void 0, void 0, function () {
            var loginResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.watchStatus = WATCH_STATUS.LOGGINGIN;
                        return [4, this.login(envId, refresh)];
                    case 1:
                        loginResult = _a.sent();
                        if (!this.envId) {
                            this.envId = loginResult.envId;
                        }
                        return [2, loginResult];
                }
            });
        }); };
        this.initWatch = function (forceRefreshLogin) { return __awaiter(_this, void 0, void 0, function () {
            var success;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._initWatchPromise) {
                            return [2, this._initWatchPromise];
                        }
                        this._initWatchPromise = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                            var envId, initWatchMsg, initEventMsg, _a, events, currEvent, _i, events_1, e, snapshot, e_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 3, , 4]);
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] initWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        return [4, this._login(this.envId, forceRefreshLogin)];
                                    case 1:
                                        envId = (_b.sent()).envId;
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] initWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        this.watchStatus = WATCH_STATUS.INITING;
                                        initWatchMsg = {
                                            watchId: this.watchId,
                                            requestId: (0, message_1.genRequestId)(),
                                            msgType: 'INIT_WATCH',
                                            msgData: {
                                                envId: envId,
                                                collName: this.collectionName,
                                                query: this.query,
                                                limit: this.limit,
                                                orderBy: this.orderBy,
                                            },
                                        };
                                        return [4, this.send({
                                                msg: initWatchMsg,
                                                waitResponse: true,
                                                skipOnMessage: true,
                                                timeout: DEFAULT_INIT_WATCH_TIMEOUT,
                                            })];
                                    case 2:
                                        initEventMsg = _b.sent();
                                        _a = initEventMsg.msgData, events = _a.events, currEvent = _a.currEvent;
                                        this.sessionInfo = {
                                            queryID: initEventMsg.msgData.queryID,
                                            currentEventId: currEvent - 1,
                                            currentDocs: [],
                                        };
                                        if (events.length > 0) {
                                            for (_i = 0, events_1 = events; _i < events_1.length; _i++) {
                                                e = events_1[_i];
                                                e.ID = currEvent;
                                            }
                                            this.handleServerEvents(initEventMsg);
                                        }
                                        else {
                                            this.sessionInfo.currentEventId = currEvent;
                                            snapshot = new snapshot_1.Snapshot({
                                                id: currEvent,
                                                docChanges: [],
                                                docs: [],
                                                type: 'init',
                                            });
                                            this.listener.onChange(snapshot);
                                            this.scheduleSendACK();
                                        }
                                        this.onWatchStart(this, this.sessionInfo.queryID);
                                        this.watchStatus = WATCH_STATUS.ACTIVE;
                                        this._availableRetries.INIT_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
                                        resolve();
                                        return [3, 4];
                                    case 3:
                                        e_1 = _b.sent();
                                        this.handleWatchEstablishmentError(e_1, {
                                            operationName: 'INIT_WATCH',
                                            resolve: resolve,
                                            reject: reject,
                                        });
                                        return [3, 4];
                                    case 4: return [2];
                                }
                            });
                        }); });
                        success = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4, this._initWatchPromise];
                    case 2:
                        _a.sent();
                        success = true;
                        return [3, 4];
                    case 3:
                        this._initWatchPromise = undefined;
                        return [7];
                    case 4:
                        console.log("[realtime] initWatch ".concat(success ? 'success' : 'fail'));
                        return [2];
                }
            });
        }); };
        this.rebuildWatch = function (forceRefreshLogin) { return __awaiter(_this, void 0, void 0, function () {
            var success;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._rebuildWatchPromise) {
                            return [2, this._rebuildWatchPromise];
                        }
                        this._rebuildWatchPromise = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                            var envId, rebuildWatchMsg, nextEventMsg, e_2;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 3, , 4]);
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] rebuildWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        return [4, this._login(this.envId, forceRefreshLogin)];
                                    case 1:
                                        envId = (_a.sent()).envId;
                                        if (!this.sessionInfo) {
                                            throw new Error('can not rebuildWatch without a successful initWatch (lack of sessionInfo)');
                                        }
                                        if (this.watchStatus === WATCH_STATUS.PAUSED) {
                                            console.log('[realtime] rebuildWatch cancelled on pause');
                                            return [2, resolve()];
                                        }
                                        this.watchStatus = WATCH_STATUS.REBUILDING;
                                        rebuildWatchMsg = {
                                            watchId: this.watchId,
                                            requestId: (0, message_1.genRequestId)(),
                                            msgType: 'REBUILD_WATCH',
                                            msgData: {
                                                envId: envId,
                                                collName: this.collectionName,
                                                queryID: this.sessionInfo.queryID,
                                                eventID: this.sessionInfo.currentEventId,
                                            },
                                        };
                                        return [4, this.send({
                                                msg: rebuildWatchMsg,
                                                waitResponse: true,
                                                skipOnMessage: false,
                                                timeout: DEFAULT_REBUILD_WATCH_TIMEOUT,
                                            })];
                                    case 2:
                                        nextEventMsg = _a.sent();
                                        this.handleServerEvents(nextEventMsg);
                                        this.watchStatus = WATCH_STATUS.ACTIVE;
                                        this._availableRetries.REBUILD_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
                                        resolve();
                                        return [3, 4];
                                    case 3:
                                        e_2 = _a.sent();
                                        this.handleWatchEstablishmentError(e_2, {
                                            operationName: 'REBUILD_WATCH',
                                            resolve: resolve,
                                            reject: reject,
                                        });
                                        return [3, 4];
                                    case 4: return [2];
                                }
                            });
                        }); });
                        success = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4, this._rebuildWatchPromise];
                    case 2:
                        _a.sent();
                        success = true;
                        return [3, 4];
                    case 3:
                        this._rebuildWatchPromise = undefined;
                        return [7];
                    case 4:
                        console.log("[realtime] rebuildWatch ".concat(success ? 'success' : 'fail'));
                        return [2];
                }
            });
        }); };
        this.handleWatchEstablishmentError = function (e, options) { return __awaiter(_this, void 0, void 0, function () {
            var isInitWatch, abortWatch, retry;
            var _this = this;
            return __generator(this, function (_a) {
                isInitWatch = options.operationName === 'INIT_WATCH';
                abortWatch = function () {
                    _this.closeWithError(new error_1.CloudSDKError({
                        errCode: isInitWatch
                            ? error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL
                            : error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL,
                        errMsg: e,
                    }));
                    options.reject(e);
                };
                retry = function (refreshLogin) {
                    if (_this.useRetryTicket(options.operationName)) {
                        if (isInitWatch) {
                            _this._initWatchPromise = undefined;
                            options.resolve(_this.initWatch(refreshLogin));
                        }
                        else {
                            _this._rebuildWatchPromise = undefined;
                            options.resolve(_this.rebuildWatch(refreshLogin));
                        }
                    }
                    else {
                        abortWatch();
                    }
                };
                this.handleCommonError(e, {
                    onSignError: function () { return retry(true); },
                    onTimeoutError: function () { return retry(false); },
                    onNotRetryableError: abortWatch,
                    onCancelledError: options.reject,
                    onUnknownError: function () { return __awaiter(_this, void 0, void 0, function () {
                        var onWSDisconnected, e_3;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 8, , 9]);
                                    onWSDisconnected = function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    this.pause();
                                                    return [4, this.onceWSConnected()];
                                                case 1:
                                                    _a.sent();
                                                    retry(true);
                                                    return [2];
                                            }
                                        });
                                    }); };
                                    if (!!this.isWSConnected()) return [3, 2];
                                    return [4, onWSDisconnected()];
                                case 1:
                                    _a.sent();
                                    return [3, 7];
                                case 2: return [4, (0, utils_1.sleep)(DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR)];
                                case 3:
                                    _a.sent();
                                    if (!(this.watchStatus === WATCH_STATUS.PAUSED)) return [3, 4];
                                    options.reject(new error_1.CancelledError("".concat(options.operationName, " cancelled due to pause after unknownError")));
                                    return [3, 7];
                                case 4:
                                    if (!!this.isWSConnected()) return [3, 6];
                                    return [4, onWSDisconnected()];
                                case 5:
                                    _a.sent();
                                    return [3, 7];
                                case 6:
                                    retry(false);
                                    _a.label = 7;
                                case 7: return [3, 9];
                                case 8:
                                    e_3 = _a.sent();
                                    retry(true);
                                    return [3, 9];
                                case 9: return [2];
                            }
                        });
                    }); },
                });
                return [2];
            });
        }); };
        this.closeWatch = function () { return __awaiter(_this, void 0, void 0, function () {
            var queryId, closeWatchMsg, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        queryId = this.sessionInfo ? this.sessionInfo.queryID : '';
                        if (this.watchStatus !== WATCH_STATUS.ACTIVE) {
                            this.watchStatus = WATCH_STATUS.CLOSED;
                            this.onWatchClose(this, queryId);
                            return [2];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, 4, 5]);
                        this.watchStatus = WATCH_STATUS.CLOSING;
                        closeWatchMsg = {
                            watchId: this.watchId,
                            requestId: (0, message_1.genRequestId)(),
                            msgType: 'CLOSE_WATCH',
                            msgData: null,
                        };
                        return [4, this.send({
                                msg: closeWatchMsg,
                            })];
                    case 2:
                        _a.sent();
                        this.sessionInfo = undefined;
                        this.watchStatus = WATCH_STATUS.CLOSED;
                        return [3, 5];
                    case 3:
                        e_4 = _a.sent();
                        this.closeWithError(new error_1.CloudSDKError({
                            errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL,
                            errMsg: e_4,
                        }));
                        return [3, 5];
                    case 4:
                        this.onWatchClose(this, queryId);
                        return [7];
                    case 5: return [2];
                }
            });
        }); };
        this.scheduleSendACK = function () {
            _this.clearACKSchedule();
            _this._ackTimeoutId = setTimeout(function () {
                if (_this._waitExpectedTimeoutId) {
                    _this.scheduleSendACK();
                }
                else {
                    _this.sendACK();
                }
            }, DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT);
        };
        this.clearACKSchedule = function () {
            if (_this._ackTimeoutId) {
                clearTimeout(_this._ackTimeoutId);
            }
        };
        this.sendACK = function () { return __awaiter(_this, void 0, void 0, function () {
            var ackMsg, e_5, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        if (this.watchStatus !== WATCH_STATUS.ACTIVE) {
                            this.scheduleSendACK();
                            return [2];
                        }
                        if (!this.sessionInfo) {
                            console.warn('[realtime listener] can not send ack without a successful initWatch (lack of sessionInfo)');
                            return [2];
                        }
                        ackMsg = {
                            watchId: this.watchId,
                            requestId: (0, message_1.genRequestId)(),
                            msgType: 'CHECK_LAST',
                            msgData: {
                                queryID: this.sessionInfo.queryID,
                                eventID: this.sessionInfo.currentEventId,
                            },
                        };
                        return [4, this.send({
                                msg: ackMsg,
                            })];
                    case 1:
                        _a.sent();
                        this.scheduleSendACK();
                        return [3, 3];
                    case 2:
                        e_5 = _a.sent();
                        if ((0, error_1.isRealtimeErrorMessageError)(e_5)) {
                            msg = e_5.payload;
                            switch (msg.msgData.code) {
                                case 'CHECK_LOGIN_FAILED':
                                case 'SIGN_EXPIRED_ERROR':
                                case 'SIGN_INVALID_ERROR':
                                case 'SIGN_PARAM_INVALID': {
                                    this.rebuildWatch();
                                    return [2];
                                }
                                case 'QUERYID_INVALID_ERROR':
                                case 'SYS_ERR':
                                case 'INVALIID_ENV':
                                case 'COLLECTION_PERMISSION_DENIED': {
                                    this.closeWithError(new error_1.CloudSDKError({
                                        errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                                        errMsg: msg.msgData.code,
                                    }));
                                    return [2];
                                }
                                default: {
                                    break;
                                }
                            }
                        }
                        if (this._availableRetries.CHECK_LAST
                            && this._availableRetries.CHECK_LAST > 0) {
                            this._availableRetries.CHECK_LAST--;
                            this.scheduleSendACK();
                        }
                        else {
                            this.closeWithError(new error_1.CloudSDKError({
                                errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                                errMsg: e_5,
                            }));
                        }
                        return [3, 3];
                    case 3: return [2];
                }
            });
        }); };
        this.handleCommonError = function (e, options) {
            if ((0, error_1.isRealtimeErrorMessageError)(e)) {
                var msg = e.payload;
                switch (msg.msgData.code) {
                    case 'CHECK_LOGIN_FAILED':
                    case 'SIGN_EXPIRED_ERROR':
                    case 'SIGN_INVALID_ERROR':
                    case 'SIGN_PARAM_INVALID': {
                        options.onSignError(e);
                        return;
                    }
                    case 'QUERYID_INVALID_ERROR':
                    case 'SYS_ERR':
                    case 'INVALIID_ENV':
                    case 'COLLECTION_PERMISSION_DENIED': {
                        options.onNotRetryableError(e);
                        return;
                    }
                    default: {
                        options.onNotRetryableError(e);
                        return;
                    }
                }
            }
            else if ((0, error_1.isTimeoutError)(e)) {
                options.onTimeoutError(e);
                return;
            }
            else if ((0, error_1.isCancelledError)(e)) {
                options.onCancelledError(e);
                return;
            }
            options.onUnknownError(e);
        };
        this.watchId = "watchid_".concat(+new Date(), "_").concat(Math.random());
        this.envId = options.envId;
        this.collectionName = options.collectionName;
        this.query = options.query;
        this.limit = options.limit;
        this.orderBy = options.orderBy;
        this.send = options.send;
        this.login = options.login;
        this.isWSConnected = options.isWSConnected;
        this.onceWSConnected = options.onceWSConnected;
        this.getWaitExpectedTimeoutLength = options.getWaitExpectedTimeoutLength;
        this.onWatchStart = options.onWatchStart;
        this.onWatchClose = options.onWatchClose;
        this.debug = options.debug;
        this._availableRetries = {
            INIT_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
            REBUILD_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
            CHECK_LAST: DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR,
        };
        this.listener = new listener_1.RealtimeListener({
            close: this.closeWatch,
            onChange: options.onChange,
            onError: options.onError,
            debug: this.debug,
            virtualClient: this,
        });
        this.initWatch();
    }
    VirtualWebSocketClient.prototype.onMessage = function (msg) {
        var _this = this;
        switch (this.watchStatus) {
            case WATCH_STATUS.PAUSED: {
                if (msg.msgType !== 'ERROR') {
                    return;
                }
                break;
            }
            case WATCH_STATUS.LOGGINGIN:
            case WATCH_STATUS.INITING:
            case WATCH_STATUS.REBUILDING: {
                console.warn("[realtime listener] internal non-fatal error: unexpected message received while ".concat(this.watchStatus));
                return;
            }
            case WATCH_STATUS.CLOSED: {
                console.warn('[realtime listener] internal non-fatal error: unexpected message received when the watch has closed');
                return;
            }
            case WATCH_STATUS.ERRORED: {
                console.warn('[realtime listener] internal non-fatal error: unexpected message received when the watch has ended with error');
                return;
            }
        }
        if (!this.sessionInfo) {
            console.warn('[realtime listener] internal non-fatal error: sessionInfo not found while message is received.');
            return;
        }
        this.scheduleSendACK();
        switch (msg.msgType) {
            case 'NEXT_EVENT': {
                console.warn("nextevent ".concat(msg.msgData.currEvent, " ignored"), msg);
                this.handleServerEvents(msg);
                break;
            }
            case 'CHECK_EVENT': {
                if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
                    this.sessionInfo.expectEventId = msg.msgData.currEvent;
                    this.clearWaitExpectedEvent();
                    this._waitExpectedTimeoutId = setTimeout(function () {
                        _this.rebuildWatch();
                    }, this.getWaitExpectedTimeoutLength());
                    console.log("[realtime] waitExpectedTimeoutLength ".concat(this.getWaitExpectedTimeoutLength()));
                }
                break;
            }
            case 'ERROR': {
                this.closeWithError(new error_1.CloudSDKError({
                    errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG,
                    errMsg: "".concat(msg.msgData.code, " - ").concat(msg.msgData.message),
                }));
                break;
            }
            default: {
                console.warn("[realtime listener] virtual client receive unexpected msg ".concat(msg.msgType, ": "), msg);
                break;
            }
        }
    };
    VirtualWebSocketClient.prototype.closeWithError = function (error) {
        var _a;
        this.watchStatus = WATCH_STATUS.ERRORED;
        this.clearACKSchedule();
        this.listener.onError(error);
        this.onWatchClose(this, ((_a = this.sessionInfo) === null || _a === void 0 ? void 0 : _a.queryID) || '');
        console.log("[realtime] client closed (".concat(this.collectionName, " ").concat(this.query, ") (watchId ").concat(this.watchId, ")"));
    };
    VirtualWebSocketClient.prototype.pause = function () {
        this.watchStatus = WATCH_STATUS.PAUSED;
        console.log("[realtime] client paused (".concat(this.collectionName, " ").concat(this.query, ") (watchId ").concat(this.watchId, ")"));
    };
    VirtualWebSocketClient.prototype.resume = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.watchStatus = WATCH_STATUS.RESUMING;
                        console.log("[realtime] client resuming with ".concat(this.sessionInfo ? 'REBUILD_WATCH' : 'INIT_WATCH', " (").concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, (this.sessionInfo ? this.rebuildWatch() : this.initWatch())];
                    case 2:
                        _a.sent();
                        console.log("[realtime] client successfully resumed (".concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"));
                        return [3, 4];
                    case 3:
                        e_6 = _a.sent();
                        console.error("[realtime] client resume failed (".concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"), e_6);
                        return [3, 4];
                    case 4: return [2];
                }
            });
        });
    };
    VirtualWebSocketClient.prototype.useRetryTicket = function (operationName) {
        if (this._availableRetries[operationName]
            && this._availableRetries[operationName] > 0) {
            this._availableRetries[operationName]--;
            console.log("[realtime] ".concat(operationName, " use a retry ticket, now only ").concat(this._availableRetries[operationName], " retry left"));
            return true;
        }
        return false;
    };
    VirtualWebSocketClient.prototype.handleServerEvents = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var e_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        this.scheduleSendACK();
                        return [4, this._handleServerEvents(msg)];
                    case 1:
                        _a.sent();
                        this._postHandleServerEventsValidityCheck(msg);
                        return [3, 3];
                    case 2:
                        e_7 = _a.sent();
                        console.error('[realtime listener] internal non-fatal error: handle server events failed with error: ', e_7);
                        throw e_7;
                    case 3: return [2];
                }
            });
        });
    };
    VirtualWebSocketClient.prototype._handleServerEvents = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var requestId, events, msgType, sessionInfo, allChangeEvents, docs, initEncountered, _loop_1, this_1, i, len, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestId = msg.requestId;
                        events = msg.msgData.events;
                        msgType = msg.msgType;
                        if (!events.length || !this.sessionInfo) {
                            return [2];
                        }
                        sessionInfo = this.sessionInfo;
                        try {
                            allChangeEvents = events.map(getPublicEvent);
                        }
                        catch (e) {
                            this.closeWithError(new error_1.CloudSDKError({
                                errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA,
                                errMsg: e,
                            }));
                            return [2];
                        }
                        docs = __spreadArray([], sessionInfo.currentDocs, true);
                        initEncountered = false;
                        _loop_1 = function (i, len) {
                            var change, localDoc, doc, fieldPath, _i, _b, fieldPath, err, err, doc, doc, err, ind, ind, docsSnapshot, docChanges, snapshot;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        change = allChangeEvents[i];
                                        if (!(sessionInfo.currentEventId >= change.id)) return [3, 1];
                                        if (!allChangeEvents[i - 1] || change.id > allChangeEvents[i - 1].id) {
                                            console.warn("[realtime] duplicate event received, cur ".concat(sessionInfo.currentEventId, " but got ").concat(change.id));
                                        }
                                        else {
                                            console.error("[realtime listener] server non-fatal error: events out of order (the latter event's id is smaller than that of the former) (requestId ".concat(requestId, ")"));
                                        }
                                        return [2, "continue"];
                                    case 1:
                                        if (!(sessionInfo.currentEventId === change.id - 1)) return [3, 2];
                                        switch (change.dataType) {
                                            case 'update': {
                                                if (!change.doc) {
                                                    switch (change.queueType) {
                                                        case 'update':
                                                        case 'dequeue': {
                                                            localDoc = docs.find(function (doc) { return doc._id === change.docId; });
                                                            if (localDoc) {
                                                                doc = (0, lodash_clonedeep_1.default)(localDoc);
                                                                if (change.updatedFields) {
                                                                    for (fieldPath in change.updatedFields) {
                                                                        (0, lodash_set_1.default)(doc, fieldPath, change.updatedFields[fieldPath]);
                                                                    }
                                                                }
                                                                if (change.removedFields) {
                                                                    for (_i = 0, _b = change.removedFields; _i < _b.length; _i++) {
                                                                        fieldPath = _b[_i];
                                                                        (0, lodash_unset_1.default)(doc, fieldPath);
                                                                    }
                                                                }
                                                                change.doc = doc;
                                                            }
                                                            else {
                                                                console.error('[realtime listener] internal non-fatal server error: unexpected update dataType event where no doc is associated.');
                                                            }
                                                            break;
                                                        }
                                                        case 'enqueue': {
                                                            err = new error_1.CloudSDKError({
                                                                errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                                                errMsg: "HandleServerEvents: full doc is not provided with dataType=\"update\" and queueType=\"enqueue\" (requestId ".concat(msg.requestId, ")"),
                                                            });
                                                            this_1.closeWithError(err);
                                                            throw err;
                                                        }
                                                        default: {
                                                            break;
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                            case 'replace': {
                                                if (!change.doc) {
                                                    err = new error_1.CloudSDKError({
                                                        errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                                        errMsg: "HandleServerEvents: full doc is not provided with dataType=\"replace\" (requestId ".concat(msg.requestId, ")"),
                                                    });
                                                    this_1.closeWithError(err);
                                                    throw err;
                                                }
                                                break;
                                            }
                                            case 'remove': {
                                                doc = docs.find(function (doc) { return doc._id === change.docId; });
                                                if (doc) {
                                                    change.doc = doc;
                                                }
                                                else {
                                                    console.error('[realtime listener] internal non-fatal server error: unexpected remove event where no doc is associated.');
                                                }
                                                break;
                                            }
                                            case 'limit': {
                                                if (!change.doc) {
                                                    switch (change.queueType) {
                                                        case 'dequeue': {
                                                            doc = docs.find(function (doc) { return doc._id === change.docId; });
                                                            if (doc) {
                                                                change.doc = doc;
                                                            }
                                                            else {
                                                                console.error('[realtime listener] internal non-fatal server error: unexpected limit dataType event where no doc is associated.');
                                                            }
                                                            break;
                                                        }
                                                        case 'enqueue': {
                                                            err = new error_1.CloudSDKError({
                                                                errCode: error_1.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                                                errMsg: "HandleServerEvents: full doc is not provided with dataType=\"limit\" and queueType=\"enqueue\" (requestId ".concat(msg.requestId, ")"),
                                                            });
                                                            this_1.closeWithError(err);
                                                            throw err;
                                                        }
                                                        default: {
                                                            break;
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                        switch (change.queueType) {
                                            case 'init': {
                                                if (!initEncountered) {
                                                    initEncountered = true;
                                                    docs = [change.doc];
                                                }
                                                else {
                                                    docs.push(change.doc);
                                                }
                                                break;
                                            }
                                            case 'enqueue': {
                                                docs.push(change.doc);
                                                break;
                                            }
                                            case 'dequeue': {
                                                ind = docs.findIndex(function (doc) { return doc._id === change.docId; });
                                                if (ind > -1) {
                                                    docs.splice(ind, 1);
                                                }
                                                else {
                                                    console.error('[realtime listener] internal non-fatal server error: unexpected dequeue event where no doc is associated.');
                                                }
                                                break;
                                            }
                                            case 'update': {
                                                ind = docs.findIndex(function (doc) { return doc._id === change.docId; });
                                                if (ind > -1) {
                                                    docs[ind] = change.doc;
                                                }
                                                else {
                                                    console.error('[realtime listener] internal non-fatal server error: unexpected queueType update event where no doc is associated.');
                                                }
                                                break;
                                            }
                                        }
                                        if (i === len - 1
                                            || (allChangeEvents[i + 1] && allChangeEvents[i + 1].id !== change.id)) {
                                            docsSnapshot = __spreadArray([], docs, true);
                                            docChanges = allChangeEvents
                                                .slice(0, i + 1)
                                                .filter(function (c) { return c.id === change.id; });
                                            this_1.sessionInfo.currentEventId = change.id;
                                            this_1.sessionInfo.currentDocs = docs;
                                            snapshot = new snapshot_1.Snapshot({
                                                id: change.id,
                                                docChanges: docChanges,
                                                docs: docsSnapshot,
                                                msgType: msgType,
                                            });
                                            this_1.listener.onChange(snapshot);
                                        }
                                        return [3, 4];
                                    case 2:
                                        console.warn("[realtime listener] event received is out of order, cur ".concat(this_1.sessionInfo.currentEventId, " but got ").concat(change.id));
                                        return [4, this_1.rebuildWatch()];
                                    case 3:
                                        _c.sent();
                                        return [2, { value: void 0 }];
                                    case 4: return [2];
                                }
                            });
                        };
                        this_1 = this;
                        i = 0, len = allChangeEvents.length;
                        _a.label = 1;
                    case 1:
                        if (!(i < len)) return [3, 4];
                        return [5, _loop_1(i, len)];
                    case 2:
                        state_1 = _a.sent();
                        if (typeof state_1 === "object")
                            return [2, state_1.value];
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    VirtualWebSocketClient.prototype._postHandleServerEventsValidityCheck = function (msg) {
        if (!this.sessionInfo) {
            console.error('[realtime listener] internal non-fatal error: sessionInfo lost after server event handling, this should never occur');
            return;
        }
        if (this.sessionInfo.expectEventId
            && this.sessionInfo.currentEventId >= this.sessionInfo.expectEventId) {
            this.clearWaitExpectedEvent();
        }
        if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
            console.warn('[realtime listener] internal non-fatal error: client eventId does not match with server event id after server event handling');
            return;
        }
    };
    VirtualWebSocketClient.prototype.clearWaitExpectedEvent = function () {
        if (this._waitExpectedTimeoutId) {
            clearTimeout(this._waitExpectedTimeoutId);
            this._waitExpectedTimeoutId = undefined;
        }
    };
    return VirtualWebSocketClient;
}());
exports.VirtualWebSocketClient = VirtualWebSocketClient;
function getPublicEvent(event) {
    var e = {
        id: event.ID,
        dataType: event.DataType,
        queueType: event.QueueType,
        docId: event.DocID,
        doc: event.Doc && event.Doc !== '{}' ? JSON.parse(event.Doc) : undefined,
    };
    if (event.DataType === 'update') {
        if (event.UpdatedFields) {
            e.updatedFields = JSON.parse(event.UpdatedFields);
        }
        if (event.removedFields || event.RemovedFields) {
            e.removedFields = JSON.parse(event.removedFields);
        }
    }
    return e;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC13ZWJzb2NrZXQtY2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ZpcnR1YWwtd2Vic29ja2V0LWNsaWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSwwREFBNkI7QUFDN0IsOERBQWlDO0FBQ2pDLHNFQUF5QztBQUN6QyxxQ0FBeUM7QUFpQnpDLHVDQUE4QztBQUM5Qyx1Q0FBc0M7QUFFdEMsaUNBU2lCO0FBQ2pCLGlDQUFnQztBQTRDaEMsSUFBSyxZQVVKO0FBVkQsV0FBSyxZQUFZO0lBQ2YsdUNBQXVCLENBQUE7SUFDdkIsbUNBQW1CLENBQUE7SUFDbkIseUNBQXlCLENBQUE7SUFDekIsaUNBQWlCLENBQUE7SUFDakIsbUNBQW1CLENBQUE7SUFDbkIsbUNBQW1CLENBQUE7SUFDbkIsaUNBQWlCLENBQUE7SUFDakIsaUNBQWlCLENBQUE7SUFDakIscUNBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQVZJLFlBQVksS0FBWixZQUFZLFFBVWhCO0FBRUQsSUFBTSxrQ0FBa0MsR0FBRyxHQUFHLENBQUM7QUFDL0MsSUFBTSwrQkFBK0IsR0FBRyxDQUFDLENBQUM7QUFDMUMsSUFBTSx3Q0FBd0MsR0FBRyxDQUFDLENBQUM7QUFDbkQsSUFBTSxpQ0FBaUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ3BELElBQU0sMEJBQTBCLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUM3QyxJQUFNLDZCQUE2QixHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFFaEQ7SUFxQ0UsZ0NBQVksT0FBa0Q7UUFBOUQsaUJBK0JDO1FBM0NPLGdCQUFXLEdBQWlCLFlBQVksQ0FBQyxPQUFPLENBQUM7UUFzTGpELFdBQU0sR0FBRyxVQUNmLEtBQWMsRUFDZCxPQUFpQjs7Ozs7d0JBRWpCLElBQUksQ0FBQyxXQUFXLEdBQUcsWUFB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QUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztLQUN6RSxDQUFDO0lBRUYsSUFBSSxLQUFLLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRTtRQUUvQixJQUFJLEtBQUssQ0FBQyxhQUFhLEVBQUU7WUFDdkIsQ0FBQyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNuRDtRQUdELElBQUksS0FBSyxDQUFDLGFBQWEsSUFBSSxLQUFLLENBQUMsYUFBYSxFQUFFO1lBSzlDLENBQUMsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbkQ7S0FDRjtJQUVELE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlcyAqL1xuaW1wb3J0IHNldCBmcm9tICdsb2Rhc2guc2V0JztcbmltcG9ydCB1bnNldCBmcm9tICdsb2Rhc2gudW5zZXQnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcbmltcG9ydCB7IGdlblJlcXVlc3RJZCB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQge1xuICBJUmVzcG9uc2VNZXNzYWdlLFxuICBJUmVxdWVzdE1lc3NhZ2VJbml0V2F0Y2hNc2csXG4gIElSZXNwb25zZU1lc3NhZ2VJbml0RXZlbnRNc2csXG4gIElEQkV2ZW50LFxuICBJUmVxdWVzdE1lc3NhZ2VSZWJ1aWxkV2F0Y2hNc2csXG4gIElSZXF1ZXN0TWVzc2FnZUNsb3NlV2F0Y2hNc2csXG4gIElSZXF1ZXN0TXNnVHlwZSxcbiAgSVJlc3BvbnNlTWVzc2FnZU5leHRFdmVudE1zZyxcbiAgSVJlcXVlc3RNZXNzYWdlQ2hlY2tMYXN0TXNnLFxuICBJV2F0Y2hPcHRpb25zLFxufSBmcm9tICdAY2xvdWRiYXNlL3R5cGVzL3JlYWx0aW1lJztcbmltcG9ydCB7XG4gIElTaW5nbGVEQkV2ZW50LFxufSBmcm9tICdAY2xvdWRiYXNlL3R5cGVzL2RhdGFiYXNlJztcbi8vIGltcG9ydCBSZXBvcnRlciBmcm9tIFwiLi9leHRlcm5hbHMvcHVibGljLWxpYi9yZXBvcnRlclwiXG5pbXBvcnQgeyBSZWFsdGltZUxpc3RlbmVyIH0gZnJvbSAnLi9saXN0ZW5lcic7XG5pbXBvcnQgeyBTbmFwc2hvdCB9IGZyb20gJy4vc25hcHNob3QnO1xuaW1wb3J0IHsgSVdTU2VuZE9wdGlvbnMsIElMb2dpblJlc3VsdCB9IGZyb20gJy4vd2Vic29ja2V0LWNsaWVudCc7XG5pbXBvcnQge1xuICBFUlJfQ09ERSxcbiAgQ2xvdWRTREtFcnJvcixcbiAgaXNUaW1lb3V0RXJyb3IsXG4gIENhbmNlbGxlZEVycm9yLFxuICBpc0NhbmNlbGxlZEVycm9yLFxuICBpc1JlYWx0aW1lRXJyb3JNZXNzYWdlRXJyb3IsXG4gIFJlYWx0aW1lRXJyb3JNZXNzYWdlRXJyb3IsXG4gIFRpbWVvdXRFcnJvcixcbn0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT0gUmVhbHRpbWUgVmlydHVhbCBXZWJTb2NrZXQgQ2xpZW50IChJbnRlcm5hbCkgPT09PT09PT09PT09PT09PT09PT1cblxuaW50ZXJmYWNlIElWaXJ0dWFsV2ViU29ja2V0Q2xpZW50Q29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgSVdhdGNoT3B0aW9ucyB7XG4gIC8vIHdzOiBSZWFsdGltZVdlYlNvY2tldENsaWVudFxuICBlbnZJZD86IHN0cmluZ1xuICBjb2xsZWN0aW9uTmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBzdHJpbmdcbiAgbGltaXQ/OiBudW1iZXJcbiAgb3JkZXJCeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgc2VuZDogPFQgPSBhbnk+KG9wdHM6IElXU1NlbmRPcHRpb25zKSA9PiBQcm9taXNlPFQ+XG4gIGxvZ2luOiAoZW52SWQ/OiBzdHJpbmcsIHJlZnJlc2g/OiBib29sZWFuKSA9PiBQcm9taXNlPGFueT5cbiAgaXNXU0Nvbm5lY3RlZDogKCkgPT4gYm9vbGVhblxuICBvbmNlV1NDb25uZWN0ZWQ6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgZ2V0V2FpdEV4cGVjdGVkVGltZW91dExlbmd0aDogKCkgPT4gbnVtYmVyXG4gIG9uV2F0Y2hTdGFydDogKGNsaWVudDogVmlydHVhbFdlYlNvY2tldENsaWVudCwgcXVlcnlJRDogc3RyaW5nKSA9PiB2b2lkXG4gIG9uV2F0Y2hDbG9zZTogKGNsaWVudDogVmlydHVhbFdlYlNvY2tldENsaWVudCwgcXVlcnlJRDogc3RyaW5nKSA9PiB2b2lkXG4gIGRlYnVnPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgSVdhdGNoU2Vzc2lvbkluZm8ge1xuICBxdWVyeUlEOiBzdHJpbmdcbiAgY3VycmVudEV2ZW50SWQ6IG51bWJlclxuICBjdXJyZW50RG9jczogUmVjb3JkPHN0cmluZywgYW55PltdXG4gIGV4cGVjdEV2ZW50SWQ/OiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIElIYW5kbGVDb21tb25FcnJvck9wdGlvbnMge1xuICBvblNpZ25FcnJvcjogKGU6IFJlYWx0aW1lRXJyb3JNZXNzYWdlRXJyb3IpID0+IHZvaWRcbiAgb25UaW1lb3V0RXJyb3I6IChlOiBUaW1lb3V0RXJyb3IpID0+IHZvaWRcbiAgb25DYW5jZWxsZWRFcnJvcjogKGU6IENhbmNlbGxlZEVycm9yKSA9PiB2b2lkXG4gIG9uTm90UmV0cnlhYmxlRXJyb3I6IChlOiBSZWFsdGltZUVycm9yTWVzc2FnZUVycm9yKSA9PiB2b2lkXG4gIG9uVW5rbm93bkVycm9yOiAoZTogYW55KSA9PiB2b2lkXG59XG5cbmludGVyZmFjZSBJSGFuZGxlV2F0Y2hFc3RhYmxpc2htZW50RXJyb3JPcHRpb25zIHtcbiAgb3BlcmF0aW9uTmFtZTogJ0lOSVRfV0FUQ0gnIHwgJ1JFQlVJTERfV0FUQ0gnXG4gIHJlc29sdmU6ICh2YWx1ZT86IFByb21pc2VMaWtlPHZvaWQ+IHwgdW5kZWZpbmVkKSA9PiB2b2lkXG4gIHJlamVjdDogKGU6IGFueSkgPT4gdm9pZFxuICAvLyByZXRyeTogKHJlZnJlc2hMb2dpbj86IGJvb2xlYW4pID0+IHZvaWRcbiAgLy8gYWJvcnRXYXRjaDogKGU6IGFueSkgPT4gdm9pZFxufVxuXG5lbnVtIFdBVENIX1NUQVRVUyB7XG4gIExPR0dJTkdJTiA9ICdMT0dHSU5HSU4nLFxuICBJTklUSU5HID0gJ0lOSVRJTkcnLFxuICBSRUJVSUxESU5HID0gJ1JFQlVJTERJTkcnLFxuICBBQ1RJVkUgPSAnQUNUSVZFJyxcbiAgRVJST1JFRCA9ICdFUlJPUkVEJyxcbiAgQ0xPU0lORyA9ICdDTE9TSU5HJyxcbiAgQ0xPU0VEID0gJ0NMT1NFRCcsXG4gIFBBVVNFRCA9ICdQQVVTRUQnLFxuICBSRVNVTUlORyA9ICdSRVNVTUlORydcbn1cblxuY29uc3QgREVGQVVMVF9XQUlUX1RJTUVfT05fVU5LTk9XTl9FUlJPUiA9IDEwMDtcbmNvbnN0IERFRkFVTFRfTUFYX0FVVE9fUkVUUllfT05fRVJST1IgPSAyO1xuY29uc3QgREVGQVVMVF9NQVhfU0VORF9BQ0tfQVVUT19SRVRSWV9PTl9FUlJPUiA9IDI7XG5jb25zdCBERUZBVUxUX1NFTkRfQUNLX0RFQk9VTkNFX1RJTUVPVVQgPSAxMCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX0lOSVRfV0FUQ0hfVElNRU9VVCA9IDEwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfUkVCVUlMRF9XQVRDSF9USU1FT1VUID0gMTAgKiAxMDAwO1xuXG5leHBvcnQgY2xhc3MgVmlydHVhbFdlYlNvY2tldENsaWVudCB7XG4gIC8vIHBhc3NlZCBvdmVyXG4gIHdhdGNoSWQ6IHN0cmluZztcbiAgLy8gb3duXG4gIGxpc3RlbmVyOiBSZWFsdGltZUxpc3RlbmVyO1xuICBwcml2YXRlIGVudklkPzogc3RyaW5nO1xuICBwcml2YXRlIGNvbGxlY3Rpb25OYW1lOiBzdHJpbmc7XG4gIHByaXZhdGUgcXVlcnk6IHN0cmluZztcbiAgcHJpdmF0ZSBsaW1pdDogbnVtYmVyO1xuICBwcml2YXRlIG9yZGVyQnk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHByaXZhdGUgc2VuZDogPFQgPSBhbnk+KG9wdHM6IElXU1NlbmRPcHRpb25zKSA9PiBQcm9taXNlPFQ+O1xuICBwcml2YXRlIGxvZ2luOiAoZW52SWQ/OiBzdHJpbmcsIHJlZnJlc2g/OiBib29sZWFuKSA9PiBQcm9taXNlPGFueT47XG4gIHByaXZhdGUgaXNXU0Nvbm5lY3RlZDogKCkgPT4gYm9vbGVhbjtcbiAgcHJpdmF0ZSBvbmNlV1NDb25uZWN0ZWQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgZ2V0V2FpdEV4cGVjdGVkVGltZW91dExlbmd0aDogKCkgPT4gbnVtYmVyO1xuICBwcml2YXRlIG9uV2F0Y2hTdGFydDogKFxuICAgIGNsaWVudDogVmlydHVhbFdlYlNvY2tldENsaWVudCxcbiAgICBxdWVyeUlEOiBzdHJpbmdcbiAgKSA9PiB2b2lkO1xuICBwcml2YXRlIG9uV2F0Y2hDbG9zZTogKFxuICAgIGNsaWVudDogVmlydHVhbFdlYlNvY2tldENsaWVudCxcbiAgICBxdWVyeUlEOiBzdHJpbmdcbiAgKSA9PiB2b2lkO1xuICBwcml2YXRlIGRlYnVnPzogYm9vbGVhbjtcblxuICBwcml2YXRlIHdhdGNoU3RhdHVzOiBXQVRDSF9TVEFUVVMgPSBXQVRDSF9TVEFUVVMuSU5JVElORztcbiAgcHJpdmF0ZSBfYXZhaWxhYmxlUmV0cmllczogUGFydGlhbDxSZWNvcmQ8SVJlcXVlc3RNc2dUeXBlLCBudW1iZXI+PjtcbiAgcHJpdmF0ZSBfYWNrVGltZW91dElkPzogbnVtYmVyO1xuICBwcml2YXRlIF9pbml0V2F0Y2hQcm9taXNlPzogUHJvbWlzZTx2b2lkPjtcbiAgcHJpdmF0ZSBfcmVidWlsZFdhdGNoUHJvbWlzZT86IFByb21pc2U8dm9pZD47XG5cbiAgLy8gb2J0YWluZWRcbiAgcHJpdmF0ZSBzZXNzaW9uSW5mbz86IElXYXRjaFNlc3Npb25JbmZvO1xuXG4gIC8vIGludGVybmFsXG4gIHByaXZhdGUgX3dhaXRFeHBlY3RlZFRpbWVvdXRJZD86IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBJVmlydHVhbFdlYlNvY2tldENsaWVudENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHRoaXMud2F0Y2hJZCA9IGB3YXRjaGlkXyR7K25ldyBEYXRlKCl9XyR7TWF0aC5yYW5kb20oKX1gO1xuICAgIHRoaXMuZW52SWQgPSBvcHRpb25zLmVudklkO1xuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBvcHRpb25zLmNvbGxlY3Rpb25OYW1lO1xuICAgIHRoaXMucXVlcnkgPSBvcHRpb25zLnF1ZXJ5O1xuICAgIHRoaXMubGltaXQgPSBvcHRpb25zLmxpbWl0O1xuICAgIHRoaXMub3JkZXJCeSA9IG9wdGlvbnMub3JkZXJCeTtcbiAgICB0aGlzLnNlbmQgPSBvcHRpb25zLnNlbmQ7XG4gICAgdGhpcy5sb2dpbiA9IG9wdGlvbnMubG9naW47XG4gICAgdGhpcy5pc1dTQ29ubmVjdGVkID0gb3B0aW9ucy5pc1dTQ29ubmVjdGVkO1xuICAgIHRoaXMub25jZVdTQ29ubmVjdGVkID0gb3B0aW9ucy5vbmNlV1NDb25uZWN0ZWQ7XG4gICAgdGhpcy5nZXRXYWl0RXhwZWN0ZWRUaW1lb3V0TGVuZ3RoID0gb3B0aW9ucy5nZXRXYWl0RXhwZWN0ZWRUaW1lb3V0TGVuZ3RoO1xuICAgIHRoaXMub25XYXRjaFN0YXJ0ID0gb3B0aW9ucy5vbldhdGNoU3RhcnQ7XG4gICAgdGhpcy5vbldhdGNoQ2xvc2UgPSBvcHRpb25zLm9uV2F0Y2hDbG9zZTtcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIHRoaXMuX2F2YWlsYWJsZVJldHJpZXMgPSB7XG4gICAgICBJTklUX1dBVENIOiBERUZBVUxUX01BWF9BVVRPX1JFVFJZX09OX0VSUk9SLFxuICAgICAgUkVCVUlMRF9XQVRDSDogREVGQVVMVF9NQVhfQVVUT19SRVRSWV9PTl9FUlJPUixcbiAgICAgIENIRUNLX0xBU1Q6IERFRkFVTFRfTUFYX1NFTkRfQUNLX0FVVE9fUkVUUllfT05fRVJST1IsXG4gICAgfTtcblxuICAgIHRoaXMubGlzdGVuZXIgPSBuZXcgUmVhbHRpbWVMaXN0ZW5lcih7XG4gICAgICBjbG9zZTogdGhpcy5jbG9zZVdhdGNoLFxuICAgICAgb25DaGFuZ2U6IG9wdGlvbnMub25DaGFuZ2UsXG4gICAgICBvbkVycm9yOiBvcHRpb25zLm9uRXJyb3IsXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1ZyxcbiAgICAgIHZpcnR1YWxDbGllbnQ6IHRoaXMsXG4gICAgfSk7XG5cbiAgICB0aGlzLmluaXRXYXRjaCgpO1xuICB9XG5cbiAgb25NZXNzYWdlKG1zZzogSVJlc3BvbnNlTWVzc2FnZSkge1xuICAgIC8vIHdhdGNoU3RhdHVzIHNhbml0eSBjaGVja1xuICAgIHN3aXRjaCAodGhpcy53YXRjaFN0YXR1cykge1xuICAgICAgY2FzZSBXQVRDSF9TVEFUVVMuUEFVU0VEOiB7XG4gICAgICAgIC8vIGlnbm9yZSBhbGwgYnV0IGVycm9yIG1lc3NhZ2VcbiAgICAgICAgaWYgKG1zZy5tc2dUeXBlICE9PSAnRVJST1InKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBXQVRDSF9TVEFUVVMuTE9HR0lOR0lOOlxuICAgICAgY2FzZSBXQVRDSF9TVEFUVVMuSU5JVElORzpcbiAgICAgIGNhc2UgV0FUQ0hfU1RBVFVTLlJFQlVJTERJTkc6IHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBlcnJvcjogdW5leHBlY3RlZCBtZXNzYWdlIHJlY2VpdmVkIHdoaWxlICR7dGhpcy53YXRjaFN0YXR1c31gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBXQVRDSF9TVEFUVVMuQ0xPU0VEOiB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IHVuZXhwZWN0ZWQgbWVzc2FnZSByZWNlaXZlZCB3aGVuIHRoZSB3YXRjaCBoYXMgY2xvc2VkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgV0FUQ0hfU1RBVFVTLkVSUk9SRUQ6IHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBlcnJvcjogdW5leHBlY3RlZCBtZXNzYWdlIHJlY2VpdmVkIHdoZW4gdGhlIHdhdGNoIGhhcyBlbmRlZCB3aXRoIGVycm9yJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbkluZm8pIHtcbiAgICAgIGNvbnNvbGUud2FybignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IHNlc3Npb25JbmZvIG5vdCBmb3VuZCB3aGlsZSBtZXNzYWdlIGlzIHJlY2VpdmVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVTZW5kQUNLKCk7XG5cbiAgICBzd2l0Y2ggKG1zZy5tc2dUeXBlKSB7XG4gICAgICBjYXNlICdORVhUX0VWRU5UJzoge1xuICAgICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAvLyBpZiAod3guX2lnbm9yZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYG5leHRldmVudCAke21zZy5tc2dEYXRhLmN1cnJFdmVudH0gaWdub3JlZGAsIG1zZyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gd3guX2lnbm9yZSA9IGZhbHNlXG4gICAgICAgIC8vIHJldHVyblxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICB0aGlzLmhhbmRsZVNlcnZlckV2ZW50cyhtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0NIRUNLX0VWRU5UJzoge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZCA8IG1zZy5tc2dEYXRhLmN1cnJFdmVudCkge1xuICAgICAgICAgIC8vIGNsaWVudCBldmVudElEIDwgc2VydmVyIGV2ZW50SUQ6XG4gICAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgb25lIG9yIG1vcmUgcGVuZGluZyBldmVudHMgbm90IHlldCByZWNlaXZlZCBidXQgc2VudCBieSB0aGUgc2VydmVyXG4gICAgICAgICAgdGhpcy5zZXNzaW9uSW5mby5leHBlY3RFdmVudElkID0gbXNnLm1zZ0RhdGEuY3VyckV2ZW50O1xuICAgICAgICAgIHRoaXMuY2xlYXJXYWl0RXhwZWN0ZWRFdmVudCgpO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICB0aGlzLl93YWl0RXhwZWN0ZWRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIG11c3QgcmVidWlsZCB3YXRjaFxuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkV2F0Y2goKTtcbiAgICAgICAgICB9LCB0aGlzLmdldFdhaXRFeHBlY3RlZFRpbWVvdXRMZW5ndGgoKSk7XG5cbiAgICAgICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSB3YWl0RXhwZWN0ZWRUaW1lb3V0TGVuZ3RoICR7dGhpcy5nZXRXYWl0RXhwZWN0ZWRUaW1lb3V0TGVuZ3RoKCl9YCk7XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnRVJST1InOiB7XG4gICAgICAgIC8vIHJlY2VpdmUgc2VydmVyIGVycm9yXG4gICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IENsb3VkU0RLRXJyb3Ioe1xuICAgICAgICAgIGVyckNvZGU6IEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9TRVJWRVJfRVJST1JfTVNHIGFzIHN0cmluZyxcbiAgICAgICAgICBlcnJNc2c6IGAke21zZy5tc2dEYXRhLmNvZGV9IC0gJHttc2cubXNnRGF0YS5tZXNzYWdlfWAsXG4gICAgICAgIH0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtyZWFsdGltZSBsaXN0ZW5lcl0gdmlydHVhbCBjbGllbnQgcmVjZWl2ZSB1bmV4cGVjdGVkIG1zZyAke21zZy5tc2dUeXBlfTogYCxcbiAgICAgICAgICBtc2dcbiAgICAgICAgKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbG9zZVdpdGhFcnJvcihlcnJvcjogYW55KSB7XG4gICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5FUlJPUkVEO1xuICAgIHRoaXMuY2xlYXJBQ0tTY2hlZHVsZSgpO1xuICAgIHRoaXMubGlzdGVuZXIub25FcnJvcihlcnJvcik7XG4gICAgLy8gUmVwb3J0ZXIuc3Vycm91bmRUaGlyZEJ5VHJ5Q2F0Y2goKCkgPT4gdGhpcy5saXN0ZW5lci5vbkVycm9yKGVycm9yKSlcbiAgICB0aGlzLm9uV2F0Y2hDbG9zZShcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLnNlc3Npb25JbmZvPy5xdWVyeUlEIHx8ICcnXG4gICAgKTtcblxuICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUubG9nKGBbcmVhbHRpbWVdIGNsaWVudCBjbG9zZWQgKCR7dGhpcy5jb2xsZWN0aW9uTmFtZX0gJHt0aGlzLnF1ZXJ5fSkgKHdhdGNoSWQgJHt0aGlzLndhdGNoSWR9KWApO1xuICAgIC8vIH1cbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuUEFVU0VEO1xuICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUubG9nKGBbcmVhbHRpbWVdIGNsaWVudCBwYXVzZWQgKCR7dGhpcy5jb2xsZWN0aW9uTmFtZX0gJHt0aGlzLnF1ZXJ5fSkgKHdhdGNoSWQgJHt0aGlzLndhdGNoSWR9KWApO1xuICAgIC8vIH1cbiAgfVxuXG4gIC8vIHJlc3VtZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5zZXNzaW9uSW5mbyA/IHRoaXMucmVidWlsZFdhdGNoKCkgOiB0aGlzLmluaXRXYXRjaCgpXG4gIC8vIH1cblxuICBhc3luYyByZXN1bWUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5SRVNVTUlORztcblxuICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUubG9nKGBbcmVhbHRpbWVdIGNsaWVudCByZXN1bWluZyB3aXRoICR7XG4gICAgICB0aGlzLnNlc3Npb25JbmZvID8gJ1JFQlVJTERfV0FUQ0gnIDogJ0lOSVRfV0FUQ0gnXG4gICAgfSAoJHt0aGlzLmNvbGxlY3Rpb25OYW1lfSAke3RoaXMucXVlcnl9KSAoJHt0aGlzLndhdGNoSWR9KWApO1xuICAgIC8vIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCAodGhpcy5zZXNzaW9uSW5mbyA/IHRoaXMucmVidWlsZFdhdGNoKCkgOiB0aGlzLmluaXRXYXRjaCgpKTtcblxuICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSBjbGllbnQgc3VjY2Vzc2Z1bGx5IHJlc3VtZWQgKCR7dGhpcy5jb2xsZWN0aW9uTmFtZX0gJHt0aGlzLnF1ZXJ5fSkgKCR7dGhpcy53YXRjaElkfSlgKTtcbiAgICAgIC8vIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBbcmVhbHRpbWVdIGNsaWVudCByZXN1bWUgZmFpbGVkICgke3RoaXMuY29sbGVjdGlvbk5hbWV9ICR7dGhpcy5xdWVyeX0pICgke3RoaXMud2F0Y2hJZH0pYCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIC8vIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9sb2dpbiA9IGFzeW5jIChcbiAgICBlbnZJZD86IHN0cmluZyxcbiAgICByZWZyZXNoPzogYm9vbGVhblxuICApOiBQcm9taXNlPElMb2dpblJlc3VsdD4gPT4ge1xuICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuTE9HR0lOR0lOO1xuICAgIGNvbnN0IGxvZ2luUmVzdWx0ID0gYXdhaXQgdGhpcy5sb2dpbihlbnZJZCwgcmVmcmVzaCk7XG4gICAgaWYgKCF0aGlzLmVudklkKSB7XG4gICAgICB0aGlzLmVudklkID0gbG9naW5SZXN1bHQuZW52SWQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dpblJlc3VsdDtcbiAgfTtcblxuICBwcml2YXRlIGluaXRXYXRjaCA9IGFzeW5jIChmb3JjZVJlZnJlc2hMb2dpbj86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAodGhpcy5faW5pdFdhdGNoUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRXYXRjaFByb21pc2U7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdFdhdGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RhdHVzID09PSBXQVRDSF9TVEFUVVMuUEFVU0VEKSB7XG4gICAgICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tyZWFsdGltZV0gaW5pdFdhdGNoIGNhbmNlbGxlZCBvbiBwYXVzZScpO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBlbnZJZCB9ID0gYXdhaXQgdGhpcy5fbG9naW4odGhpcy5lbnZJZCwgZm9yY2VSZWZyZXNoTG9naW4pO1xuXG4gICAgICAgIC8vIGlmICghdGhpcy5zZXNzaW9uSW5mbykge1xuICAgICAgICAvLyAgIHRocm93IG5ldyBFcnJvcihgY2FuIG5vdCByZWJ1aWxkV2F0Y2ggd2l0aG91dCBhIHN1Y2Nlc3NmdWwgaW5pdFdhdGNoIChsYWNrIG9mIHNlc3Npb25JbmZvKWApXG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoKHRoaXMud2F0Y2hTdGF0dXMgYXMgV0FUQ0hfU1RBVFVTKSA9PT0gV0FUQ0hfU1RBVFVTLlBBVVNFRCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbcmVhbHRpbWVdIGluaXRXYXRjaCBjYW5jZWxsZWQgb24gcGF1c2UnKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5JTklUSU5HO1xuXG4gICAgICAgIGNvbnN0IGluaXRXYXRjaE1zZzogSVJlcXVlc3RNZXNzYWdlSW5pdFdhdGNoTXNnID0ge1xuICAgICAgICAgIHdhdGNoSWQ6IHRoaXMud2F0Y2hJZCxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGdlblJlcXVlc3RJZCgpLFxuICAgICAgICAgIG1zZ1R5cGU6ICdJTklUX1dBVENIJyxcbiAgICAgICAgICBtc2dEYXRhOiB7XG4gICAgICAgICAgICBlbnZJZCxcbiAgICAgICAgICAgIGNvbGxOYW1lOiB0aGlzLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgcXVlcnk6IHRoaXMucXVlcnksXG4gICAgICAgICAgICBsaW1pdDogdGhpcy5saW1pdCxcbiAgICAgICAgICAgIG9yZGVyQnk6IHRoaXMub3JkZXJCeSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGluaXRFdmVudE1zZyA9IGF3YWl0IHRoaXMuc2VuZDxJUmVzcG9uc2VNZXNzYWdlSW5pdEV2ZW50TXNnPih7XG4gICAgICAgICAgbXNnOiBpbml0V2F0Y2hNc2csXG4gICAgICAgICAgd2FpdFJlc3BvbnNlOiB0cnVlLFxuICAgICAgICAgIHNraXBPbk1lc3NhZ2U6IHRydWUsXG4gICAgICAgICAgdGltZW91dDogREVGQVVMVF9JTklUX1dBVENIX1RJTUVPVVQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgZXZlbnRzLCBjdXJyRXZlbnQgfSA9IGluaXRFdmVudE1zZy5tc2dEYXRhO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbkluZm8gPSB7XG4gICAgICAgICAgcXVlcnlJRDogaW5pdEV2ZW50TXNnLm1zZ0RhdGEucXVlcnlJRCxcbiAgICAgICAgICBjdXJyZW50RXZlbnRJZDogY3VyckV2ZW50IC0gMSxcbiAgICAgICAgICBjdXJyZW50RG9jczogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRklYOiBpbiBpbml0RXZlbnQgbWVzc2FnZSwgYWxsIGV2ZW50cyBoYXZlIGlkIDAsIHdoaWNoIGlzIGluY29uc2lzdGVudCB3aXRoIGN1cnJFdmVudFxuICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICBlLklEID0gY3VyckV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZVNlcnZlckV2ZW50cyhpbml0RXZlbnRNc2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWQgPSBjdXJyRXZlbnQ7XG4gICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3Qoe1xuICAgICAgICAgICAgaWQ6IGN1cnJFdmVudCxcbiAgICAgICAgICAgIGRvY0NoYW5nZXM6IFtdLFxuICAgICAgICAgICAgZG9jczogW10sXG4gICAgICAgICAgICB0eXBlOiAnaW5pdCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkNoYW5nZShzbmFwc2hvdCk7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZVNlbmRBQ0soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uV2F0Y2hTdGFydCh0aGlzLCB0aGlzLnNlc3Npb25JbmZvLnF1ZXJ5SUQpO1xuICAgICAgICB0aGlzLndhdGNoU3RhdHVzID0gV0FUQ0hfU1RBVFVTLkFDVElWRTtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlUmV0cmllcy5JTklUX1dBVENIID0gREVGQVVMVF9NQVhfQVVUT19SRVRSWV9PTl9FUlJPUjtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVdhdGNoRXN0YWJsaXNobWVudEVycm9yKGUsIHtcbiAgICAgICAgICBvcGVyYXRpb25OYW1lOiAnSU5JVF9XQVRDSCcsXG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9pbml0V2F0Y2hQcm9taXNlO1xuICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2luaXRXYXRjaFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgY29uc29sZS5sb2coYFtyZWFsdGltZV0gaW5pdFdhdGNoICR7c3VjY2VzcyA/ICdzdWNjZXNzJyA6ICdmYWlsJ31gKTtcbiAgICAvLyB9XG4gIH07XG5cbiAgcHJpdmF0ZSByZWJ1aWxkV2F0Y2ggPSBhc3luYyAoZm9yY2VSZWZyZXNoTG9naW4/OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHRoaXMuX3JlYnVpbGRXYXRjaFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWJ1aWxkV2F0Y2hQcm9taXNlO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYnVpbGRXYXRjaFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy53YXRjaFN0YXR1cyA9PT0gV0FUQ0hfU1RBVFVTLlBBVVNFRCkge1xuICAgICAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbcmVhbHRpbWVdIHJlYnVpbGRXYXRjaCBjYW5jZWxsZWQgb24gcGF1c2UnKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGVudklkIH0gPSBhd2FpdCB0aGlzLl9sb2dpbih0aGlzLmVudklkLCBmb3JjZVJlZnJlc2hMb2dpbik7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb25JbmZvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW4gbm90IHJlYnVpbGRXYXRjaCB3aXRob3V0IGEgc3VjY2Vzc2Z1bCBpbml0V2F0Y2ggKGxhY2sgb2Ygc2Vzc2lvbkluZm8pJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHRoaXMud2F0Y2hTdGF0dXMgYXMgV0FUQ0hfU1RBVFVTKSA9PT0gV0FUQ0hfU1RBVFVTLlBBVVNFRCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbcmVhbHRpbWVdIHJlYnVpbGRXYXRjaCBjYW5jZWxsZWQgb24gcGF1c2UnKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5SRUJVSUxESU5HO1xuXG4gICAgICAgIGNvbnN0IHJlYnVpbGRXYXRjaE1zZzogSVJlcXVlc3RNZXNzYWdlUmVidWlsZFdhdGNoTXNnID0ge1xuICAgICAgICAgIHdhdGNoSWQ6IHRoaXMud2F0Y2hJZCxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGdlblJlcXVlc3RJZCgpLFxuICAgICAgICAgIG1zZ1R5cGU6ICdSRUJVSUxEX1dBVENIJyxcbiAgICAgICAgICBtc2dEYXRhOiB7XG4gICAgICAgICAgICBlbnZJZCxcbiAgICAgICAgICAgIGNvbGxOYW1lOiB0aGlzLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgcXVlcnlJRDogdGhpcy5zZXNzaW9uSW5mby5xdWVyeUlELFxuICAgICAgICAgICAgZXZlbnRJRDogdGhpcy5zZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG5leHRFdmVudE1zZyA9IGF3YWl0IHRoaXMuc2VuZDxJUmVzcG9uc2VNZXNzYWdlTmV4dEV2ZW50TXNnPih7XG4gICAgICAgICAgbXNnOiByZWJ1aWxkV2F0Y2hNc2csXG4gICAgICAgICAgd2FpdFJlc3BvbnNlOiB0cnVlLFxuICAgICAgICAgIHNraXBPbk1lc3NhZ2U6IGZhbHNlLFxuICAgICAgICAgIHRpbWVvdXQ6IERFRkFVTFRfUkVCVUlMRF9XQVRDSF9USU1FT1VULFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmhhbmRsZVNlcnZlckV2ZW50cyhuZXh0RXZlbnRNc2cpO1xuXG4gICAgICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuQUNUSVZFO1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVSZXRyaWVzLlJFQlVJTERfV0FUQ0ggPSBERUZBVUxUX01BWF9BVVRPX1JFVFJZX09OX0VSUk9SO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlV2F0Y2hFc3RhYmxpc2htZW50RXJyb3IoZSwge1xuICAgICAgICAgIG9wZXJhdGlvbk5hbWU6ICdSRUJVSUxEX1dBVENIJyxcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlYnVpbGRXYXRjaFByb21pc2U7XG4gICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fcmVidWlsZFdhdGNoUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSByZWJ1aWxkV2F0Y2ggJHtzdWNjZXNzID8gJ3N1Y2Nlc3MnIDogJ2ZhaWwnfWApO1xuICAgIC8vIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVdhdGNoRXN0YWJsaXNobWVudEVycm9yID0gYXN5bmMgKFxuICAgIGU6IGFueSxcbiAgICBvcHRpb25zOiBJSGFuZGxlV2F0Y2hFc3RhYmxpc2htZW50RXJyb3JPcHRpb25zXG4gICkgPT4ge1xuICAgIGNvbnN0IGlzSW5pdFdhdGNoID0gb3B0aW9ucy5vcGVyYXRpb25OYW1lID09PSAnSU5JVF9XQVRDSCc7XG5cbiAgICBjb25zdCBhYm9ydFdhdGNoID0gKCkgPT4ge1xuICAgICAgLy8gbW9jayB0ZW1wIGNvbW1lbnRcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IENsb3VkU0RLRXJyb3Ioe1xuICAgICAgICBlcnJDb2RlOiBpc0luaXRXYXRjaFxuICAgICAgICAgID8gKEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9JTklUX1dBVENIX0ZBSUwgYXMgc3RyaW5nKVxuICAgICAgICAgIDogKEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9SRUJVSUxEX1dBVENIX0ZBSUwgYXMgc3RyaW5nKSxcbiAgICAgICAgZXJyTXNnOiBlLFxuICAgICAgfSkpO1xuICAgICAgb3B0aW9ucy5yZWplY3QoZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJldHJ5ID0gKHJlZnJlc2hMb2dpbj86IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmICh0aGlzLnVzZVJldHJ5VGlja2V0KG9wdGlvbnMub3BlcmF0aW9uTmFtZSkpIHtcbiAgICAgICAgaWYgKGlzSW5pdFdhdGNoKSB7XG4gICAgICAgICAgdGhpcy5faW5pdFdhdGNoUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBvcHRpb25zLnJlc29sdmUodGhpcy5pbml0V2F0Y2gocmVmcmVzaExvZ2luKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVidWlsZFdhdGNoUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBvcHRpb25zLnJlc29sdmUodGhpcy5yZWJ1aWxkV2F0Y2gocmVmcmVzaExvZ2luKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFib3J0V2F0Y2goKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVDb21tb25FcnJvcihlLCB7XG4gICAgICBvblNpZ25FcnJvcjogKCkgPT4gcmV0cnkodHJ1ZSksXG4gICAgICBvblRpbWVvdXRFcnJvcjogKCkgPT4gcmV0cnkoZmFsc2UpLFxuICAgICAgb25Ob3RSZXRyeWFibGVFcnJvcjogYWJvcnRXYXRjaCxcbiAgICAgIG9uQ2FuY2VsbGVkRXJyb3I6IG9wdGlvbnMucmVqZWN0LFxuICAgICAgb25Vbmtub3duRXJyb3I6IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvbldTRGlzY29ubmVjdGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbmNlV1NDb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIHJldHJ5KHRydWUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNXU0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCBvbldTRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKERFRkFVTFRfV0FJVF9USU1FX09OX1VOS05PV05fRVJST1IpO1xuICAgICAgICAgICAgaWYgKHRoaXMud2F0Y2hTdGF0dXMgPT09IFdBVENIX1NUQVRVUy5QQVVTRUQpIHtcbiAgICAgICAgICAgICAgLy8gY2FuY2VsXG4gICAgICAgICAgICAgIG9wdGlvbnMucmVqZWN0KG5ldyBDYW5jZWxsZWRFcnJvcihgJHtvcHRpb25zLm9wZXJhdGlvbk5hbWV9IGNhbmNlbGxlZCBkdWUgdG8gcGF1c2UgYWZ0ZXIgdW5rbm93bkVycm9yYCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1dTQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgYXdhaXQgb25XU0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0cnkoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgaGFuZGxpbmcgZXJyb3IsIGluIG9yZGVyIHRvIHByb3ZpZGUgbWF4aW11bSBlZmZvcnQgb24gU0VBTUlOR0xFU1MgRkFVTFQgVE9MRVJBTkNFLCBqdXN0IHJldHJ5XG4gICAgICAgICAgcmV0cnkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBjbG9zZVdhdGNoID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHF1ZXJ5SWQgPSB0aGlzLnNlc3Npb25JbmZvID8gdGhpcy5zZXNzaW9uSW5mby5xdWVyeUlEIDogJyc7XG5cbiAgICBpZiAodGhpcy53YXRjaFN0YXR1cyAhPT0gV0FUQ0hfU1RBVFVTLkFDVElWRSkge1xuICAgICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5DTE9TRUQ7XG4gICAgICB0aGlzLm9uV2F0Y2hDbG9zZSh0aGlzLCBxdWVyeUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy53YXRjaFN0YXR1cyA9IFdBVENIX1NUQVRVUy5DTE9TSU5HO1xuXG4gICAgICBjb25zdCBjbG9zZVdhdGNoTXNnOiBJUmVxdWVzdE1lc3NhZ2VDbG9zZVdhdGNoTXNnID0ge1xuICAgICAgICB3YXRjaElkOiB0aGlzLndhdGNoSWQsXG4gICAgICAgIHJlcXVlc3RJZDogZ2VuUmVxdWVzdElkKCksXG4gICAgICAgIG1zZ1R5cGU6ICdDTE9TRV9XQVRDSCcsXG4gICAgICAgIG1zZ0RhdGE6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICBtc2c6IGNsb3NlV2F0Y2hNc2csXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXNzaW9uSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMud2F0Y2hTdGF0dXMgPSBXQVRDSF9TVEFUVVMuQ0xPU0VEO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IENsb3VkU0RLRXJyb3Ioe1xuICAgICAgICBlcnJDb2RlOiBFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfQ0xPU0VfV0FUQ0hfRkFJTCBhcyBzdHJpbmcsXG4gICAgICAgIGVyck1zZzogZSxcbiAgICAgIH0pKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5vbldhdGNoQ2xvc2UodGhpcywgcXVlcnlJZCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgc2NoZWR1bGVTZW5kQUNLID0gKCkgPT4ge1xuICAgIHRoaXMuY2xlYXJBQ0tTY2hlZHVsZSgpO1xuXG4gICAgLy8gVE9ETzogc2hvdWxkIHdlIGNoZWNrIHN0YXR1cyBhZnRlciB0aW1lb3V0XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuX2Fja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3dhaXRFeHBlY3RlZFRpbWVvdXRJZCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlU2VuZEFDSygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5kQUNLKCk7XG4gICAgICB9XG4gICAgfSwgREVGQVVMVF9TRU5EX0FDS19ERUJPVU5DRV9USU1FT1VUKTtcbiAgfTtcblxuICBwcml2YXRlIGNsZWFyQUNLU2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuX2Fja1RpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Fja1RpbWVvdXRJZCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgc2VuZEFDSyA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMud2F0Y2hTdGF0dXMgIT09IFdBVENIX1NUQVRVUy5BQ1RJVkUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVNlbmRBQ0soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc2Vzc2lvbkluZm8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGNhbiBub3Qgc2VuZCBhY2sgd2l0aG91dCBhIHN1Y2Nlc3NmdWwgaW5pdFdhdGNoIChsYWNrIG9mIHNlc3Npb25JbmZvKScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFja01zZzogSVJlcXVlc3RNZXNzYWdlQ2hlY2tMYXN0TXNnID0ge1xuICAgICAgICB3YXRjaElkOiB0aGlzLndhdGNoSWQsXG4gICAgICAgIHJlcXVlc3RJZDogZ2VuUmVxdWVzdElkKCksXG4gICAgICAgIG1zZ1R5cGU6ICdDSEVDS19MQVNUJyxcbiAgICAgICAgbXNnRGF0YToge1xuICAgICAgICAgIHF1ZXJ5SUQ6IHRoaXMuc2Vzc2lvbkluZm8ucXVlcnlJRCxcbiAgICAgICAgICBldmVudElEOiB0aGlzLnNlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgbXNnOiBhY2tNc2csXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2hlZHVsZVNlbmRBQ0soKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPOiByZWZhY3RvclxuICAgICAgaWYgKGlzUmVhbHRpbWVFcnJvck1lc3NhZ2VFcnJvcihlKSkge1xuICAgICAgICBjb25zdCBtc2cgPSBlLnBheWxvYWQ7XG4gICAgICAgIHN3aXRjaCAobXNnLm1zZ0RhdGEuY29kZSkge1xuICAgICAgICAgIC8vIHNpZ25hdHVyZSBlcnJvciAtPiByZXRyeSB3aXRoIHJlZnJlc2hlZCBzaWduYXR1cmVcbiAgICAgICAgICBjYXNlICdDSEVDS19MT0dJTl9GQUlMRUQnOlxuICAgICAgICAgIGNhc2UgJ1NJR05fRVhQSVJFRF9FUlJPUic6XG4gICAgICAgICAgY2FzZSAnU0lHTl9JTlZBTElEX0VSUk9SJzpcbiAgICAgICAgICBjYXNlICdTSUdOX1BBUkFNX0lOVkFMSUQnOiB7XG4gICAgICAgICAgICB0aGlzLnJlYnVpbGRXYXRjaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlciAtPiB0aHJvd1xuICAgICAgICAgIGNhc2UgJ1FVRVJZSURfSU5WQUxJRF9FUlJPUic6XG4gICAgICAgICAgY2FzZSAnU1lTX0VSUic6XG4gICAgICAgICAgY2FzZSAnSU5WQUxJSURfRU5WJzpcbiAgICAgICAgICBjYXNlICdDT0xMRUNUSU9OX1BFUk1JU1NJT05fREVOSUVEJzoge1xuICAgICAgICAgICAgLy8gbXVzdCB0aHJvd1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihuZXcgQ2xvdWRTREtFcnJvcih7XG4gICAgICAgICAgICAgIGVyckNvZGU6IEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9DSEVDS19MQVNUX0ZBSUwgYXMgc3RyaW5nLFxuICAgICAgICAgICAgICBlcnJNc2c6IG1zZy5tc2dEYXRhLmNvZGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBtYXliZSByZXRyeWFibGVcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlUmV0cmllcy5DSEVDS19MQVNUXG4gICAgICAgICYmIHRoaXMuX2F2YWlsYWJsZVJldHJpZXMuQ0hFQ0tfTEFTVCA+IDBcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVSZXRyaWVzLkNIRUNLX0xBU1QtLTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVNlbmRBQ0soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IENsb3VkU0RLRXJyb3Ioe1xuICAgICAgICAgIGVyckNvZGU6IEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9DSEVDS19MQVNUX0ZBSUwgYXMgc3RyaW5nLFxuICAgICAgICAgIGVyck1zZzogZSxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUNvbW1vbkVycm9yID0gKFxuICAgIGU6IGFueSxcbiAgICBvcHRpb25zOiBJSGFuZGxlQ29tbW9uRXJyb3JPcHRpb25zXG4gICk6IHZvaWQgPT4ge1xuICAgIGlmIChpc1JlYWx0aW1lRXJyb3JNZXNzYWdlRXJyb3IoZSkpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGUucGF5bG9hZDtcbiAgICAgIHN3aXRjaCAobXNnLm1zZ0RhdGEuY29kZSkge1xuICAgICAgICAvLyBzaWduYXR1cmUgZXJyb3IgLT4gcmV0cnkgd2l0aCByZWZyZXNoZWQgc2lnbmF0dXJlXG4gICAgICAgIGNhc2UgJ0NIRUNLX0xPR0lOX0ZBSUxFRCc6XG4gICAgICAgIGNhc2UgJ1NJR05fRVhQSVJFRF9FUlJPUic6XG4gICAgICAgIGNhc2UgJ1NJR05fSU5WQUxJRF9FUlJPUic6XG4gICAgICAgIGNhc2UgJ1NJR05fUEFSQU1fSU5WQUxJRCc6IHtcbiAgICAgICAgICBvcHRpb25zLm9uU2lnbkVycm9yKGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QtcmV0cnlhYmxlIGVycm9yIC0+IHRocm93XG4gICAgICAgIGNhc2UgJ1FVRVJZSURfSU5WQUxJRF9FUlJPUic6XG4gICAgICAgIGNhc2UgJ1NZU19FUlInOlxuICAgICAgICBjYXNlICdJTlZBTElJRF9FTlYnOlxuICAgICAgICBjYXNlICdDT0xMRUNUSU9OX1BFUk1JU1NJT05fREVOSUVEJzoge1xuICAgICAgICAgIG9wdGlvbnMub25Ob3RSZXRyeWFibGVFcnJvcihlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIG9wdGlvbnMub25Ob3RSZXRyeWFibGVFcnJvcihlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGltZW91dEVycm9yKGUpKSB7XG4gICAgICAvLyB0aW1lb3V0IGVycm9yXG4gICAgICBvcHRpb25zLm9uVGltZW91dEVycm9yKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNDYW5jZWxsZWRFcnJvcihlKSkge1xuICAgICAgLy8gY2FuY2VsbGVkIGVycm9yXG4gICAgICBvcHRpb25zLm9uQ2FuY2VsbGVkRXJyb3IoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdW5rbm93biBlcnJvclxuICAgIG9wdGlvbnMub25Vbmtub3duRXJyb3IoZSk7XG4gIH07XG5cbiAgLy8gY3JlZGl0IGEgcmV0cnkgY2hhbmNlIGZyb20gYXZhaWxhYmxlUmV0cmllc1xuICBwcml2YXRlIHVzZVJldHJ5VGlja2V0KG9wZXJhdGlvbk5hbWU6IElSZXF1ZXN0TXNnVHlwZSk6IGJvb2xlYW4ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuX2F2YWlsYWJsZVJldHJpZXNbb3BlcmF0aW9uTmFtZV1cbiAgICAgICYmIHRoaXMuX2F2YWlsYWJsZVJldHJpZXNbb3BlcmF0aW9uTmFtZV0hID4gMFxuICAgICkge1xuICAgICAgdGhpcy5fYXZhaWxhYmxlUmV0cmllc1tvcGVyYXRpb25OYW1lXSEtLTtcblxuICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW3JlYWx0aW1lXSAke29wZXJhdGlvbk5hbWV9IHVzZSBhIHJldHJ5IHRpY2tldCwgbm93IG9ubHkgJHt0aGlzLl9hdmFpbGFibGVSZXRyaWVzW29wZXJhdGlvbk5hbWVdfSByZXRyeSBsZWZ0YCk7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVNlcnZlckV2ZW50cyhtc2c6IElSZXNwb25zZU1lc3NhZ2VJbml0RXZlbnRNc2cgfCBJUmVzcG9uc2VNZXNzYWdlTmV4dEV2ZW50TXNnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2NoZWR1bGVTZW5kQUNLKCk7XG4gICAgICBhd2FpdCB0aGlzLl9oYW5kbGVTZXJ2ZXJFdmVudHMobXNnKTtcbiAgICAgIHRoaXMuX3Bvc3RIYW5kbGVTZXJ2ZXJFdmVudHNWYWxpZGl0eUNoZWNrKG1zZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICAvLyBUT0RPOiByZXBvcnRcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBlcnJvcjogaGFuZGxlIHNlcnZlciBldmVudHMgZmFpbGVkIHdpdGggZXJyb3I6ICcsXG4gICAgICAgIGVcbiAgICAgICk7XG5cbiAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgLy8gICBcIndzZXJyb3IudHh0XCIsXG4gICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBlcnJvcjogaGFuZGxlIHNlcnZlciBldmVudHMgZmFpbGVkIHdpdGggZXJyb3I6ICAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgLy8gICAgIE9iamVjdC5hc3NpZ24oe30sIGUsIHtcbiAgICAgIC8vICAgICAgIHJlcXVlc3RJZDogbXNnLnJlcXVlc3RJZCxcbiAgICAgIC8vICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAvLyAgICAgfSlcbiAgICAgIC8vICAgKX0gXFxuYFxuICAgICAgLy8gKVxuICAgICAgLy8gfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2hhbmRsZVNlcnZlckV2ZW50cyhtc2c6IElSZXNwb25zZU1lc3NhZ2VJbml0RXZlbnRNc2cgfCBJUmVzcG9uc2VNZXNzYWdlTmV4dEV2ZW50TXNnKSB7XG4gICAgY29uc3QgeyByZXF1ZXN0SWQgfSA9IG1zZztcblxuICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBtc2cubXNnRGF0YTtcbiAgICBjb25zdCB7IG1zZ1R5cGUgfSA9IG1zZztcblxuICAgIGlmICghZXZlbnRzLmxlbmd0aCB8fCAhdGhpcy5zZXNzaW9uSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2Vzc2lvbkluZm8gfSA9IHRoaXM7XG5cbiAgICBsZXQgYWxsQ2hhbmdlRXZlbnRzOiBJU2luZ2xlREJFdmVudFtdO1xuICAgIHRyeSB7XG4gICAgICBhbGxDaGFuZ2VFdmVudHMgPSBldmVudHMubWFwKGdldFB1YmxpY0V2ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgZXJyQ29kZTogRVJSX0NPREUuU0RLX0RBVEFCQVNFX1JFQUxUSU1FX0xJU1RFTkVSX1JFQ0VJVkVfSU5WQUxJRF9TRVJWRVJfREFUQSBhcyBzdHJpbmcsXG4gICAgICAgIGVyck1zZzogZSxcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZ2dyZWdhdGUgZG9jc1xuICAgIGxldCBkb2NzID0gWy4uLnNlc3Npb25JbmZvLmN1cnJlbnREb2NzXTtcbiAgICBsZXQgaW5pdEVuY291bnRlcmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFsbENoYW5nZUV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY2hhbmdlID0gYWxsQ2hhbmdlRXZlbnRzW2ldO1xuXG4gICAgICBpZiAoc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWQgPj0gY2hhbmdlLmlkKSB7XG4gICAgICAgIGlmICghYWxsQ2hhbmdlRXZlbnRzW2kgLSAxXSB8fCBjaGFuZ2UuaWQgPiBhbGxDaGFuZ2VFdmVudHNbaSAtIDFdLmlkKSB7XG4gICAgICAgICAgLy8gZHVwbGljYXRlIGV2ZW50LCBkcm9wYWJsZVxuICAgICAgICAgIC8vIFRPRE86IHJlcG9ydFxuICAgICAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgW3JlYWx0aW1lXSBkdXBsaWNhdGUgZXZlbnQgcmVjZWl2ZWQsIGN1ciAke3Nlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkfSBidXQgZ290ICR7Y2hhbmdlLmlkfWApO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhbGxDaGFuZ2VFdmVudHMgc2hvdWxkIGJlIGluIGFzY2VuZGluZyBvcmRlciBhY2NvcmRpbmcgdG8gZXZlbnRJZCwgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVucywgbXVzdCByZXBvcnQgYSBub24tZmF0YWwgZXJyb3JcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbcmVhbHRpbWUgbGlzdGVuZXJdIHNlcnZlciBub24tZmF0YWwgZXJyb3I6IGV2ZW50cyBvdXQgb2Ygb3JkZXIgKHRoZSBsYXR0ZXIgZXZlbnQncyBpZCBpcyBzbWFsbGVyIHRoYW4gdGhhdCBvZiB0aGUgZm9ybWVyKSAocmVxdWVzdElkICR7cmVxdWVzdElkfSlgKTtcblxuICAgICAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgICAgIC8vICAgYFtyZWFsdGltZSBsaXN0ZW5lcl0gc2VydmVyIG5vbi1mYXRhbCBlcnJvcjogZXZlbnRzIG91dCBvZiBvcmRlciAodGhlIGxhdHRlciBldmVudCdzIGlkIGlzIHNtYWxsZXIgdGhhbiB0aGF0IG9mIHRoZSBmb3JtZXIpICAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIC8vICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIC8vICAgICAgIHt9LFxuICAgICAgICAgIC8vICAgICAgIHtcbiAgICAgICAgICAvLyAgICAgICAgIHJlcXVlc3RJZDogbXNnLnJlcXVlc3RJZCxcbiAgICAgICAgICAvLyAgICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgIC8vICAgICApXG4gICAgICAgICAgLy8gICApfSBcXG5gXG4gICAgICAgICAgLy8gKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZCA9PT0gY2hhbmdlLmlkIC0gMSkge1xuICAgICAgICAvLyBjb3JyZWN0IHNlcXVlbmNlXG4gICAgICAgIC8vIGZpcnN0IGhhbmRsZSBkYXRhVHlwZSB0aGVuIHF1ZXVlVHlwZTpcbiAgICAgICAgLy8gMS4gZGF0YVR5cGU6IHdlIE9OTFkgcG9wdWxhdGUgY2hhbmdlLmRvYyBpZiBuZWNjZXNzYXJ5XG4gICAgICAgIC8vIDIuIHF1ZXVlVHlwZTogd2UgYnVpbGQgdGhlIGRhdGEgc25hcHNob3RcblxuICAgICAgICBzd2l0Y2ggKGNoYW5nZS5kYXRhVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6IHtcbiAgICAgICAgICAgIC8vIG9ubHkgbmVlZCB0byBwb3B1bGF0ZSBjaGFuZ2UuZG9jIHdoZW4gaXQgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoIWNoYW5nZS5kb2MpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2UucXVldWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXF1ZXVlJzoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxEb2MgPSBkb2NzLmZpbmQoZG9jID0+IGRvYy5faWQgPT09IGNoYW5nZS5kb2NJZCk7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBwYXJ0aWFsIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSBjbG9uZURlZXAobG9jYWxEb2MpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UudXBkYXRlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRQYXRoIGluIGNoYW5nZS51cGRhdGVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQoZG9jLCBmaWVsZFBhdGgsIGNoYW5nZS51cGRhdGVkRmllbGRzW2ZpZWxkUGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVtb3ZlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRQYXRoIG9mIGNoYW5nZS5yZW1vdmVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNldChkb2MsIGZpZWxkUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRvYyA9IGRvYztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVwb3J0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIHNlcnZlciBlcnJvcjogdW5leHBlY3RlZCB1cGRhdGUgZGF0YVR5cGUgZXZlbnQgd2hlcmUgbm8gZG9jIGlzIGFzc29jaWF0ZWQuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGVUb0ZpbGUoXG4gICAgICAgICAgICAgICAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgdXBkYXRlIGRhdGFUeXBlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLiAgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmVxdWVzdElkOiBtc2cucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIClcbiAgICAgICAgICAgICAgICAgICAgLy8gICApfSBcXG5gXG4gICAgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdlbnF1ZXVlJzoge1xuICAgICAgICAgICAgICAgICAgLy8gZG9jIGlzIHByb3ZpZGVkIGJ5IHNlcnZlciwgdGhpcyBzaG91bGQgbmV2ZXIgb2NjdXJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyQ29kZTogRVJSX0NPREUuU0RLX0RBVEFCQVNFX1JFQUxUSU1FX0xJU1RFTkVSX1VORVhQRUNURURfRkFUQUxfRVJST1IgYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBlcnJNc2c6IGBIYW5kbGVTZXJ2ZXJFdmVudHM6IGZ1bGwgZG9jIGlzIG5vdCBwcm92aWRlZCB3aXRoIGRhdGFUeXBlPVwidXBkYXRlXCIgYW5kIHF1ZXVlVHlwZT1cImVucXVldWVcIiAocmVxdWVzdElkICR7bXNnLnJlcXVlc3RJZH0pYCxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyZXBsYWNlJzoge1xuICAgICAgICAgICAgLy8gdmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCFjaGFuZ2UuZG9jKSB7XG4gICAgICAgICAgICAgIC8vIGRvYyBpcyBwcm92aWRlZCBieSBzZXJ2ZXIsIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyXG4gICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBDbG91ZFNES0Vycm9yKHtcbiAgICAgICAgICAgICAgICBlcnJDb2RlOiBFUlJfQ09ERS5TREtfREFUQUJBU0VfUkVBTFRJTUVfTElTVEVORVJfVU5FWFBFQ1RFRF9GQVRBTF9FUlJPUiBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgZXJyTXNnOiBgSGFuZGxlU2VydmVyRXZlbnRzOiBmdWxsIGRvYyBpcyBub3QgcHJvdmlkZWQgd2l0aCBkYXRhVHlwZT1cInJlcGxhY2VcIiAocmVxdWVzdElkICR7bXNnLnJlcXVlc3RJZH0pYCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGRvY3MuZmluZChkb2MgPT4gZG9jLl9pZCA9PT0gY2hhbmdlLmRvY0lkKTtcbiAgICAgICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgICAgY2hhbmdlLmRvYyA9IGRvYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gcmVwb3J0XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIHNlcnZlciBlcnJvcjogdW5leHBlY3RlZCByZW1vdmUgZXZlbnQgd2hlcmUgbm8gZG9jIGlzIGFzc29jaWF0ZWQuJyk7XG5cbiAgICAgICAgICAgICAgLy8gd3JpdGVUb0ZpbGUoXG4gICAgICAgICAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgICAgICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgcmVtb3ZlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAvLyAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgLy8gICAgICAge30sXG4gICAgICAgICAgICAgIC8vICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gICAgICAgICByZXF1ZXN0SWQ6IG1zZy5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIC8vICAgICAgICAgd2F0Y2hJZDogbXNnLndhdGNoSWRcbiAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAvLyAgICAgKVxuICAgICAgICAgICAgICAvLyAgICl9IFxcbmBcbiAgICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xpbWl0Jzoge1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2UuZG9jKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlLnF1ZXVlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlcXVldWUnOiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSBkb2NzLmZpbmQoZG9jID0+IGRvYy5faWQgPT09IGNoYW5nZS5kb2NJZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kb2MgPSBkb2M7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgbGltaXQgZGF0YVR5cGUgZXZlbnQgd2hlcmUgbm8gZG9jIGlzIGFzc29jaWF0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5xdWV1ZSc6IHtcbiAgICAgICAgICAgICAgICAgIC8vIGRvYyBpcyBwcm92aWRlZCBieSBzZXJ2ZXIsIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyXG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgQ2xvdWRTREtFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVyckNvZGU6IEVSUl9DT0RFLlNES19EQVRBQkFTRV9SRUFMVElNRV9MSVNURU5FUl9VTkVYUEVDVEVEX0ZBVEFMX0VSUk9SIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnOiBgSGFuZGxlU2VydmVyRXZlbnRzOiBmdWxsIGRvYyBpcyBub3QgcHJvdmlkZWQgd2l0aCBkYXRhVHlwZT1cImxpbWl0XCIgYW5kIHF1ZXVlVHlwZT1cImVucXVldWVcIiAocmVxdWVzdElkICR7bXNnLnJlcXVlc3RJZH0pYCxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY2hhbmdlLnF1ZXVlVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2luaXQnOiB7XG4gICAgICAgICAgICBpZiAoIWluaXRFbmNvdW50ZXJlZCkge1xuICAgICAgICAgICAgICBpbml0RW5jb3VudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBkb2NzID0gW2NoYW5nZS5kb2NdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9jcy5wdXNoKGNoYW5nZS5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2VucXVldWUnOiB7XG4gICAgICAgICAgICBkb2NzLnB1c2goY2hhbmdlLmRvYyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZGVxdWV1ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGluZCA9IGRvY3MuZmluZEluZGV4KGRvYyA9PiBkb2MuX2lkID09PSBjaGFuZ2UuZG9jSWQpO1xuICAgICAgICAgICAgaWYgKGluZCA+IC0xKSB7XG4gICAgICAgICAgICAgIGRvY3Muc3BsaWNlKGluZCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUT0RPIHJlcG9ydFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgZGVxdWV1ZSBldmVudCB3aGVyZSBubyBkb2MgaXMgYXNzb2NpYXRlZC4nKTtcblxuICAgICAgICAgICAgICAvLyB3cml0ZVRvRmlsZShcbiAgICAgICAgICAgICAgLy8gICBcIndzZXJyb3IudHh0XCIsXG4gICAgICAgICAgICAgIC8vICAgYFtyZWFsdGltZSBsaXN0ZW5lcl0gaW50ZXJuYWwgbm9uLWZhdGFsIHNlcnZlciBlcnJvcjogdW5leHBlY3RlZCBkZXF1ZXVlIGV2ZW50IHdoZXJlIG5vIGRvYyBpcyBhc3NvY2lhdGVkLiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAvLyAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgLy8gICAgICAge30sXG4gICAgICAgICAgICAgIC8vICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gICAgICAgICByZXF1ZXN0SWQ6IG1zZy5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIC8vICAgICAgICAgd2F0Y2hJZDogbXNnLndhdGNoSWRcbiAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAvLyAgICAgKVxuICAgICAgICAgICAgICAvLyAgICl9IFxcbmBcbiAgICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6IHtcbiAgICAgICAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgICAgICAgLy8gICBcIndzZXJyb3IudHh0XCIsXG4gICAgICAgICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGRvY3MgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIC8vICAgICBkb2NzXG4gICAgICAgICAgICAvLyAgICl9IGNoYW5nZSBkb2MgJHtKU09OLnN0cmluZ2lmeShjaGFuZ2UpfSBcXG5gXG4gICAgICAgICAgICAvLyApXG4gICAgICAgICAgICBjb25zdCBpbmQgPSBkb2NzLmZpbmRJbmRleChkb2MgPT4gZG9jLl9pZCA9PT0gY2hhbmdlLmRvY0lkKTtcbiAgICAgICAgICAgIGlmIChpbmQgPiAtMSkge1xuICAgICAgICAgICAgICBkb2NzW2luZF0gPSBjaGFuZ2UuZG9jO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyByZXBvcnRcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgc2VydmVyIGVycm9yOiB1bmV4cGVjdGVkIHF1ZXVlVHlwZSB1cGRhdGUgZXZlbnQgd2hlcmUgbm8gZG9jIGlzIGFzc29jaWF0ZWQuJyk7XG5cbiAgICAgICAgICAgICAgLy8gd3JpdGVUb0ZpbGUoXG4gICAgICAgICAgICAgIC8vICAgXCJ3c2Vycm9yLnR4dFwiLFxuICAgICAgICAgICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBzZXJ2ZXIgZXJyb3I6IHVuZXhwZWN0ZWQgcXVldWVUeXBlIHVwZGF0ZSBldmVudCB3aGVyZSBubyBkb2MgaXMgYXNzb2NpYXRlZC4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgLy8gICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIC8vICAgICAgIHt9LFxuICAgICAgICAgICAgICAvLyAgICAgICB7XG4gICAgICAgICAgICAgIC8vICAgICAgICAgcmVxdWVzdElkOiBtc2cucmVxdWVzdElkLFxuICAgICAgICAgICAgICAvLyAgICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gICAgIClcbiAgICAgICAgICAgICAgLy8gICApfSBcXG5gXG4gICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpID09PSBsZW4gLSAxXG4gICAgICAgICAgfHwgKGFsbENoYW5nZUV2ZW50c1tpICsgMV0gJiYgYWxsQ2hhbmdlRXZlbnRzW2kgKyAxXS5pZCAhPT0gY2hhbmdlLmlkKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBhIHNoYWxsb3cgc2xpY2UgY3JlYXRlcyBhIHNoYWxsb3cgc25hcHNob3RcbiAgICAgICAgICBjb25zdCBkb2NzU25hcHNob3QgPSBbLi4uZG9jc107XG5cbiAgICAgICAgICAvLyB3ZSBzbGljZSBmaXJzdCBjYXVzZScgaWYgdGhlcmUncmUgYWxsQ2hhbmdlRXZlbnRzIHRoYXQgYXJlIG9mIHRoZSBzYW1lIGlkIGFmdGVyIHRoaXMgY2hhbmdlLCB3ZSBkb24ndCB3YW50IHRvIGludm9sdmUgaXQgZm9yIGl0IGlzIHVuZXhwZWN0ZWQgaW52YWxpZCBvcmRlclxuICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSBhbGxDaGFuZ2VFdmVudHNcbiAgICAgICAgICAgIC5zbGljZSgwLCBpICsgMSlcbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLmlkID09PSBjaGFuZ2UuaWQpO1xuXG4gICAgICAgICAgLy8gYWxsIGNoYW5nZXMgb2YgdGhpcyBldmVudCBoYXMgYmVlbiBoYW5kbGUsIHdlIGNvdWxkIGRpc3BhdGNoIHRoZSBldmVudCBub3dcbiAgICAgICAgICB0aGlzLnNlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkID0gY2hhbmdlLmlkO1xuICAgICAgICAgIHRoaXMuc2Vzc2lvbkluZm8uY3VycmVudERvY3MgPSBkb2NzO1xuXG4gICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3Qoe1xuICAgICAgICAgICAgaWQ6IGNoYW5nZS5pZCxcbiAgICAgICAgICAgIGRvY0NoYW5nZXMsXG4gICAgICAgICAgICBkb2NzOiBkb2NzU25hcHNob3QsXG4gICAgICAgICAgICBtc2dUeXBlLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVwb3J0ZXIuc3Vycm91bmRUaGlyZEJ5VHJ5Q2F0Y2goKCkgPT5cbiAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uQ2hhbmdlKHNuYXBzaG90KTtcbiAgICAgICAgICAvLyApKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3V0LW9mLW9yZGVyIGV2ZW50XG4gICAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgICAvLyBUT0RPOiByZXBvcnRcbiAgICAgICAgY29uc29sZS53YXJuKGBbcmVhbHRpbWUgbGlzdGVuZXJdIGV2ZW50IHJlY2VpdmVkIGlzIG91dCBvZiBvcmRlciwgY3VyICR7dGhpcy5zZXNzaW9uSW5mby5jdXJyZW50RXZlbnRJZH0gYnV0IGdvdCAke2NoYW5nZS5pZH1gKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyByZWJ1aWxkIHdhdGNoXG4gICAgICAgIGF3YWl0IHRoaXMucmVidWlsZFdhdGNoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9wb3N0SGFuZGxlU2VydmVyRXZlbnRzVmFsaWRpdHlDaGVjayhtc2c6IElSZXNwb25zZU1lc3NhZ2VJbml0RXZlbnRNc2cgfCBJUmVzcG9uc2VNZXNzYWdlTmV4dEV2ZW50TXNnKSB7XG4gICAgaWYgKCF0aGlzLnNlc3Npb25JbmZvKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBlcnJvcjogc2Vzc2lvbkluZm8gbG9zdCBhZnRlciBzZXJ2ZXIgZXZlbnQgaGFuZGxpbmcsIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyJyk7XG5cbiAgICAgIC8vIHdyaXRlVG9GaWxlKFxuICAgICAgLy8gICBcIndzZXJyb3IudHh0XCIsXG4gICAgICAvLyAgIGBbcmVhbHRpbWUgbGlzdGVuZXJdIGludGVybmFsIG5vbi1mYXRhbCBlcnJvcjogc2Vzc2lvbkluZm8gbG9zdCBhZnRlciBzZXJ2ZXIgZXZlbnQgaGFuZGxpbmcsIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAvLyAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgIC8vICAgICAgIHt9LFxuICAgICAgLy8gICAgICAge1xuICAgICAgLy8gICAgICAgICByZXF1ZXN0SWQ6IG1zZy5yZXF1ZXN0SWQsXG4gICAgICAvLyAgICAgICAgIHdhdGNoSWQ6IG1zZy53YXRjaElkXG4gICAgICAvLyAgICAgICB9XG4gICAgICAvLyAgICAgKVxuICAgICAgLy8gICApfSBcXG5gXG4gICAgICAvLyApXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5zZXNzaW9uSW5mby5leHBlY3RFdmVudElkXG4gICAgICAmJiB0aGlzLnNlc3Npb25JbmZvLmN1cnJlbnRFdmVudElkID49IHRoaXMuc2Vzc2lvbkluZm8uZXhwZWN0RXZlbnRJZFxuICAgICkge1xuICAgICAgdGhpcy5jbGVhcldhaXRFeHBlY3RlZEV2ZW50KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2Vzc2lvbkluZm8uY3VycmVudEV2ZW50SWQgPCBtc2cubXNnRGF0YS5jdXJyRXZlbnQpIHtcbiAgICAgIGNvbnNvbGUud2FybignW3JlYWx0aW1lIGxpc3RlbmVyXSBpbnRlcm5hbCBub24tZmF0YWwgZXJyb3I6IGNsaWVudCBldmVudElkIGRvZXMgbm90IG1hdGNoIHdpdGggc2VydmVyIGV2ZW50IGlkIGFmdGVyIHNlcnZlciBldmVudCBoYW5kbGluZycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJXYWl0RXhwZWN0ZWRFdmVudCgpIHtcbiAgICBpZiAodGhpcy5fd2FpdEV4cGVjdGVkVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fd2FpdEV4cGVjdGVkVGltZW91dElkKTtcbiAgICAgIHRoaXMuX3dhaXRFeHBlY3RlZFRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljRXZlbnQoZXZlbnQ6IElEQkV2ZW50KTogSVNpbmdsZURCRXZlbnQge1xuICBjb25zdCBlOiBJU2luZ2xlREJFdmVudCA9IHtcbiAgICBpZDogZXZlbnQuSUQsXG4gICAgZGF0YVR5cGU6IGV2ZW50LkRhdGFUeXBlLFxuICAgIHF1ZXVlVHlwZTogZXZlbnQuUXVldWVUeXBlLFxuICAgIGRvY0lkOiBldmVudC5Eb2NJRCxcbiAgICBkb2M6IGV2ZW50LkRvYyAmJiBldmVudC5Eb2MgIT09ICd7fScgPyBKU09OLnBhcnNlKGV2ZW50LkRvYykgOiB1bmRlZmluZWQsXG4gIH07XG5cbiAgaWYgKGV2ZW50LkRhdGFUeXBlID09PSAndXBkYXRlJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoZXZlbnQuVXBkYXRlZEZpZWxkcykge1xuICAgICAgZS51cGRhdGVkRmllbGRzID0gSlNPTi5wYXJzZShldmVudC5VcGRhdGVkRmllbGRzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogd2FpdCBmb3IgdGNiIHRvIGNoYW5nZSByZW1vdmVkRmllbGRzIHRvIFJlbW92ZWRGaWVsZHNcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGV2ZW50LnJlbW92ZWRGaWVsZHMgfHwgZXZlbnQuUmVtb3ZlZEZpZWxkcykge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLy8gZS5yZW1vdmVkRmllbGRzID0gZXZlbnQucmVtb3ZlZEZpZWxkc1xuICAgICAgLy8gICA/IEpTT04ucGFyc2UoZXZlbnQucmVtb3ZlZEZpZWxkcylcbiAgICAgIC8vICAgOiBKU09OLnBhcnNlKGV2ZW50LlJlbW92ZWRGaWVsZHMpXG4gICAgICBlLnJlbW92ZWRGaWVsZHMgPSBKU09OLnBhcnNlKGV2ZW50LnJlbW92ZWRGaWVsZHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlO1xufVxuIl19