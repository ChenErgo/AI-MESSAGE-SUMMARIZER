"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.catchErrorsDecorator = void 0;
var util_1 = require("../libs/util");
var constants_1 = require("../constants");
var isFirefox = false;
if (typeof navigator !== 'undefined' && navigator.userAgent) {
    isFirefox = navigator.userAgent.indexOf('Firefox') !== -1;
}
var REG_STACK_DECORATE = isFirefox
    ? /(\.js\/)?__decorate(\$\d+)?<@.*\d$/
    : /(\/\w+\.js\.)?__decorate(\$\d+)?\s*\(.*\)$/;
var REG_STACK_LINK = /https?\:\/\/.+\:\d*\/.*\.js\:\d+\:\d+/;
function catchErrorsDecorator(options) {
    var _a = options.mode, mode = _a === void 0 ? 'async' : _a, _b = options.customInfo, customInfo = _b === void 0 ? {} : _b, title = options.title, _c = options.messages, messages = _c === void 0 ? [] : _c;
    return function (target, methodName, descriptor) {
        if (!constants_1.IS_DEBUG_MODE) {
            return;
        }
        var className = customInfo.className || target.constructor.name;
        var fnName = customInfo.methodName || methodName;
        var fn = descriptor.value;
        var sourceLink = getSourceLink(new Error());
        if (mode === 'sync') {
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var innerErr = getRewritedError({
                    err: new Error(),
                    className: className,
                    methodName: fnName,
                    sourceLink: sourceLink,
                });
                try {
                    return fn.apply(this, args);
                }
                catch (err) {
                    var failErr = err;
                    var errMsg = err.message;
                    var logs = {
                        title: title || "".concat(className, ".").concat(fnName, " failed"),
                        content: [{
                                type: 'error',
                                body: err,
                            }],
                    };
                    if (errMsg && /^\{.*\}$/.test(errMsg)) {
                        var msg = JSON.parse(errMsg);
                        logs.subtitle = errMsg;
                        if (msg.code) {
                            if (innerErr) {
                                innerErr.code = msg.code;
                                innerErr.msg = msg.msg;
                            }
                            else {
                                err.code = msg.code;
                                err.message = msg.msg;
                            }
                            failErr = innerErr || err;
                            logs.content = messages.map(function (msg) { return ({
                                type: 'info',
                                body: msg,
                            }); });
                        }
                    }
                    (0, util_1.printGroupLog)(logs);
                    throw failErr;
                }
            };
        }
        else {
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return __awaiter(this, void 0, void 0, function () {
                    var innerErr, err_1, failErr, errMsg, logs, msg;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                innerErr = getRewritedError({
                                    err: new Error(),
                                    className: className,
                                    methodName: fnName,
                                    sourceLink: sourceLink,
                                });
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4, fn.apply(this, args)];
                            case 2: return [2, _a.sent()];
                            case 3:
                                err_1 = _a.sent();
                                failErr = err_1;
                                errMsg = err_1.message;
                                logs = {
                                    title: title || "".concat(className, ".").concat(fnName, " failed"),
                                    content: [{
                                            type: 'error',
                                            body: err_1,
                                        }],
                                };
                                if (errMsg && /^\{.*\}$/.test(errMsg)) {
                                    msg = JSON.parse(errMsg);
                                    logs.subtitle = msg;
                                    if (msg.code) {
                                        if (innerErr) {
                                            innerErr.code = msg.code;
                                            innerErr.message = msg.msg;
                                        }
                                        else {
                                            err_1.code = msg.code;
                                            err_1.message = msg.msg;
                                        }
                                        failErr = innerErr || err_1;
                                        logs.content = messages.map(function (msg) { return ({
                                            type: 'info',
                                            body: msg,
                                        }); });
                                    }
                                }
                                (0, util_1.printGroupLog)(logs);
                                throw failErr;
                            case 4: return [2];
                        }
                    });
                });
            };
        }
    };
}
exports.catchErrorsDecorator = catchErrorsDecorator;
function getSourceLink(err) {
    var sourceLink = '';
    var outterErrStacks = err.stack.split('\n');
    var indexOfDecorator = outterErrStacks.findIndex(function (str) { return REG_STACK_DECORATE.test(str); });
    if (indexOfDecorator !== -1) {
        var match = REG_STACK_LINK.exec(outterErrStacks[indexOfDecorator + 1] || '');
        sourceLink = match ? match[0] : '';
    }
    return sourceLink;
}
function getRewritedError(options) {
    var err = options.err, className = options.className, methodName = options.methodName, sourceLink = options.sourceLink;
    if (!sourceLink) {
        return null;
    }
    var innerErrStack = err.stack.split('\n');
    var REG_STACK_INNER_METHOD = isFirefox
        ? /^catchErrorsDecorator\/<\/descriptor.value@.*\d$/
        : new RegExp("".concat(className, "\\.descriptor.value\\s*\\[as\\s").concat(methodName, "\\]\\s*\\(.*\\)$"));
    var REG_STACK_INNER_METHOD_WITHOUT_LINK = isFirefox
        ? /^catchErrorsDecorator\/<\/descriptor.value/
        : new RegExp("".concat(className, "\\.descriptor.value\\s*\\[as\\s").concat(methodName, "\\]"));
    var indexOfSource = innerErrStack.findIndex(function (str) { return REG_STACK_INNER_METHOD.test(str); });
    var innerErr;
    if (indexOfSource !== -1) {
        var realErrStack = innerErrStack.filter(function (v, i) { return i > indexOfSource; });
        realErrStack.unshift(innerErrStack[indexOfSource]
            .replace(REG_STACK_INNER_METHOD_WITHOUT_LINK, "".concat(className, ".").concat(methodName))
            .replace(REG_STACK_LINK, sourceLink));
        innerErr = new Error();
        innerErr.stack = "".concat(isFirefox ? '@debugger' : 'Error', "\n").concat(realErrStack.join('\n'));
    }
    return innerErr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oZWxwZXJzL2RlY29yYXRvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EscUNBQTZDO0FBQzdDLDBDQUE2QztBQVk3QyxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdEIsSUFBSSxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDLFNBQVMsRUFBRTtJQUMzRCxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDM0Q7QUFJRCxJQUFNLGtCQUFrQixHQUFHLFNBQVM7SUFDbEMsQ0FBQyxDQUFDLG9DQUFvQztJQUN0QyxDQUFDLENBQUMsNENBQTRDLENBQUM7QUFDakQsSUFBTSxjQUFjLEdBQUcsdUNBQXVDLENBQUM7QUFLL0QsU0FBZ0Isb0JBQW9CLENBQUMsT0FBcUM7SUFDaEUsSUFBQSxLQUEwRCxPQUFPLEtBQW5ELEVBQWQsSUFBSSxtQkFBRyxPQUFPLEtBQUEsRUFBRSxLQUEwQyxPQUFPLFdBQWxDLEVBQWYsVUFBVSxtQkFBRyxFQUFFLEtBQUEsRUFBRSxLQUFLLEdBQW9CLE9BQU8sTUFBM0IsRUFBRSxLQUFrQixPQUFPLFNBQVosRUFBYixRQUFRLG1CQUFHLEVBQUUsS0FBQSxDQUFhO0lBRTFFLE9BQU8sVUFDTCxNQUFXLEVBQ1gsVUFBa0IsRUFDbEIsVUFBNkM7UUFHN0MsSUFBSSxDQUFDLHlCQUFhLEVBQUU7WUFDbEIsT0FBTztTQUNSO1FBQ0QsSUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUNsRSxJQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQztRQUNuRCxJQUFNLEVBQUUs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U0FBUyxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFoQyxDQUFnQyxDQUFDLENBQUM7SUFDdkYsSUFBSSxRQUFlLENBQUM7SUFDcEIsSUFBSSxhQUFhLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFFeEIsSUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssT0FBQSxDQUFDLEdBQUcsYUFBYSxFQUFqQixDQUFpQixDQUFDLENBQUM7UUFDdkUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDO2FBQzlDLE9BQU8sQ0FBQyxtQ0FBbUMsRUFBRSxVQUFHLFNBQVMsY0FBSSxVQUFVLENBQUUsQ0FBQzthQUMxRSxPQUFPLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDeEMsUUFBUSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDdkIsUUFBUSxDQUFDLEtBQUssR0FBRyxVQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLGVBQUssWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBRSxDQUFDO0tBQ3JGO0lBQ0QsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG5pbXBvcnQgeyBwcmludEdyb3VwTG9nIH0gZnJvbSAnLi4vbGlicy91dGlsJztcbmltcG9ydCB7IElTX0RFQlVHX01PREUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5pbnRlcmZhY2UgSUNhdGNoRXJyb3JzRGVjb3JhdG9yT3B0aW9ucyB7XG4gIG1vZGU/OiAnc3luYycgfCAnYXN5bmMnO1xuICBjdXN0b21JbmZvPzoge1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBtZXRob2ROYW1lPzogc3RyaW5nO1xuICB9O1xuICB0aXRsZT86IHN0cmluZztcbiAgbWVzc2FnZXM/OiBzdHJpbmdbXTtcbn1cbi8vIGZpcmVmb3jnmoRzdGFja+agvOW8j+S4jmNocm9tZeS4jeWQjFxubGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQpIHtcbiAgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgIT09IC0xO1xufVxuLyoqXG4gKiBkZWNvcmF0ZeWcqHN0YWNr5Lit5LiA6Iis6YO954m55a6a55qE6KeE6IyDXG4gKi9cbmNvbnN0IFJFR19TVEFDS19ERUNPUkFURSA9IGlzRmlyZWZveFxuICA/IC8oXFwuanNcXC8pP19fZGVjb3JhdGUoXFwkXFxkKyk/PEAuKlxcZCQvXG4gIDogLyhcXC9cXHcrXFwuanNcXC4pP19fZGVjb3JhdGUoXFwkXFxkKyk/XFxzKlxcKC4qXFwpJC87XG5jb25zdCBSRUdfU1RBQ0tfTElOSyA9IC9odHRwcz9cXDpcXC9cXC8uK1xcOlxcZCpcXC8uKlxcLmpzXFw6XFxkK1xcOlxcZCsvO1xuLyoqXG4gKiBkZWJ1Z+aooeW8j+W8uuWMluaXpeW/l+S/oeaBr1xuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhdGNoRXJyb3JzRGVjb3JhdG9yKG9wdGlvbnM6IElDYXRjaEVycm9yc0RlY29yYXRvck9wdGlvbnMpIHtcbiAgY29uc3QgeyBtb2RlID0gJ2FzeW5jJywgY3VzdG9tSW5mbyA9IHt9LCB0aXRsZSwgbWVzc2FnZXMgPSBbXSB9ID0gb3B0aW9ucztcblxuICByZXR1cm4gZnVuY3Rpb24gKFxuICAgIHRhcmdldDogYW55LFxuICAgIG1ldGhvZE5hbWU6IHN0cmluZyxcbiAgICBkZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxGdW5jdGlvbj5cbiAgKSB7XG4gICAgLy8g55Sf5Lqn546v5aKD56aB55SoXG4gICAgaWYgKCFJU19ERUJVR19NT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGN1c3RvbUluZm8uY2xhc3NOYW1lIHx8IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IGZuTmFtZSA9IGN1c3RvbUluZm8ubWV0aG9kTmFtZSB8fCBtZXRob2ROYW1lO1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICAgIC8vIOiiq2RlY29yYXRvcuijhemlsOeahOa6kOeggWxpbmtcbiAgICAvLyDlnKhkZXNjcmlwdG9yLnZhbHVl5aSW6YOo5q2k5aSE5Yib5bu655qEc3RhY2vlsYLmrKHlj6/op6bovr7mupDnoIFcbiAgICAvLyDogIxkZXNjcmlwdG9yLnZhbHVl5YaF6YOo5pyJ5Y+v6IO955Sx5LqOc3RhY2vlpKrmt7Hml6Dms5Xop6bovr5cbiAgICBjb25zdCBzb3VyY2VMaW5rID0gZ2V0U291cmNlTGluayhuZXcgRXJyb3IoKSk7XG5cbiAgICBpZiAobW9kZSA9PT0gJ3N5bmMnKSB7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIC8vIOatpOWkhOeahHN0YWNr5L2c55So5Li76KaB5piv5Li65LqG6I635Y+W6KKrZGVjb3JhdG9y6KOF6aWw55qE5rqQ56CBY2xhc3PlkoxtZXRob2TlkI3np7BcbiAgICAgICAgY29uc3QgaW5uZXJFcnI6IGFueSA9IGdldFJld3JpdGVkRXJyb3Ioe1xuICAgICAgICAgIGVycjogbmV3IEVycm9yKCksXG4gICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgIG1ldGhvZE5hbWU6IGZuTmFtZSxcbiAgICAgICAgICBzb3VyY2VMaW5rLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxldCBmYWlsRXJyID0gZXJyO1xuICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZXJyTXNnIH0gPSBlcnI7XG4gICAgICAgICAgY29uc3QgbG9nczogYW55ID0ge1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlIHx8IGAke2NsYXNzTmFtZX0uJHtmbk5hbWV9IGZhaWxlZGAsXG4gICAgICAgICAgICBjb250ZW50OiBbe1xuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICBib2R5OiBlcnIsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIOWPqueJueauiuWkhOeQhlNES+S4muWKoemAu+i+keaKm+WHuueahOmUmeivry1KU09OIHN0cmluZ1xuICAgICAgICAgIGlmIChlcnJNc2cgJiYgL15cXHsuKlxcfSQvLnRlc3QoZXJyTXNnKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShlcnJNc2cpO1xuICAgICAgICAgICAgbG9ncy5zdWJ0aXRsZSA9IGVyck1zZztcbiAgICAgICAgICAgIGlmIChtc2cuY29kZSkge1xuICAgICAgICAgICAgICBpZiAoaW5uZXJFcnIpIHtcbiAgICAgICAgICAgICAgICBpbm5lckVyci5jb2RlID0gbXNnLmNvZGU7XG4gICAgICAgICAgICAgICAgaW5uZXJFcnIubXNnID0gbXNnLm1zZztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IG1zZy5jb2RlO1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbXNnLm1zZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmYWlsRXJyID0gaW5uZXJFcnIgfHwgZXJyO1xuICAgICAgICAgICAgICBsb2dzLmNvbnRlbnQgPSBtZXNzYWdlcy5tYXAobXNnID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2luZm8nLFxuICAgICAgICAgICAgICAgIGJvZHk6IG1zZyxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcmludEdyb3VwTG9nKGxvZ3MpO1xuICAgICAgICAgIHRocm93IGZhaWxFcnI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgY29uc3QgaW5uZXJFcnI6IGFueSA9IGdldFJld3JpdGVkRXJyb3Ioe1xuICAgICAgICAgIGVycjogbmV3IEVycm9yKCksXG4gICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgIG1ldGhvZE5hbWU6IGZuTmFtZSxcbiAgICAgICAgICBzb3VyY2VMaW5rLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxldCBmYWlsRXJyID0gZXJyO1xuICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZXJyTXNnIH0gPSBlcnI7XG4gICAgICAgICAgY29uc3QgbG9nczogYW55ID0ge1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlIHx8IGAke2NsYXNzTmFtZX0uJHtmbk5hbWV9IGZhaWxlZGAsXG4gICAgICAgICAgICBjb250ZW50OiBbe1xuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICBib2R5OiBlcnIsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIOWPqueJueauiuWkhOeQhlNES+S4muWKoemAu+i+keaKm+WHuueahOmUmeivry1KU09OIHN0cmluZ1xuICAgICAgICAgIGlmIChlcnJNc2cgJiYgL15cXHsuKlxcfSQvLnRlc3QoZXJyTXNnKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShlcnJNc2cpO1xuICAgICAgICAgICAgbG9ncy5zdWJ0aXRsZSA9IG1zZztcbiAgICAgICAgICAgIGlmIChtc2cuY29kZSkge1xuICAgICAgICAgICAgICBpZiAoaW5uZXJFcnIpIHtcbiAgICAgICAgICAgICAgICBpbm5lckVyci5jb2RlID0gbXNnLmNvZGU7XG4gICAgICAgICAgICAgICAgaW5uZXJFcnIubWVzc2FnZSA9IG1zZy5tc2c7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBtc2cuY29kZTtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IG1zZy5tc2c7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmFpbEVyciA9IGlubmVyRXJyIHx8IGVycjtcbiAgICAgICAgICAgICAgbG9ncy5jb250ZW50ID0gbWVzc2FnZXMubWFwKG1zZyA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdpbmZvJyxcbiAgICAgICAgICAgICAgICBib2R5OiBtc2csXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJpbnRHcm91cExvZyhsb2dzKTtcbiAgICAgICAgICB0aHJvdyBmYWlsRXJyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiDlnKjljp/lp4vloIbmoIjkuK3mn6Xmib7oo4XppbDlmajmnaHnm67lubbov5Tlm57mupDnoIHpk77mjqVsaW5rXG4gKiBAcGFyYW0gZXJyXG4gKi9cbmZ1bmN0aW9uIGdldFNvdXJjZUxpbmsoZXJyOiBFcnJvcikge1xuICBsZXQgc291cmNlTGluayA9ICcnO1xuICBjb25zdCBvdXR0ZXJFcnJTdGFja3MgPSBlcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuICBjb25zdCBpbmRleE9mRGVjb3JhdG9yID0gb3V0dGVyRXJyU3RhY2tzLmZpbmRJbmRleChzdHIgPT4gUkVHX1NUQUNLX0RFQ09SQVRFLnRlc3Qoc3RyKSk7XG4gIGlmIChpbmRleE9mRGVjb3JhdG9yICE9PSAtMSkge1xuICAgIGNvbnN0IG1hdGNoID0gUkVHX1NUQUNLX0xJTksuZXhlYyhvdXR0ZXJFcnJTdGFja3NbaW5kZXhPZkRlY29yYXRvciArIDFdIHx8ICcnKTtcbiAgICBzb3VyY2VMaW5rID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICB9XG4gIHJldHVybiBzb3VyY2VMaW5rO1xufVxuXG4vKipcbiAqIOWcqOWOn+Wni+WghuagiOS4reafpeaJvuijhemlsOWZqOadoeebru+8jOWJlOmZpOWFtuWQjueahOaXoOeUqOWghuagiO+8jOW5tuWwhumTvuaOpeabv+aNouS4uua6kOeggWxpbmtcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFJld3JpdGVkRXJyb3Iob3B0aW9uczoge1xuICBlcnI6IEVycm9yO1xuICBjbGFzc05hbWU6IHN0cmluZztcbiAgbWV0aG9kTmFtZTogc3RyaW5nO1xuICBzb3VyY2VMaW5rOiBzdHJpbmc7XG59KSB7XG4gIGNvbnN0IHsgZXJyLCBjbGFzc05hbWUsIG1ldGhvZE5hbWUsIHNvdXJjZUxpbmsgfSA9IG9wdGlvbnM7XG4gIC8vIOaJvuS4jeWIsOa6kOeggWxpbmvov5Tlm55udWxs77yM5ZCO57ut6YC76L6R5bCG5omT5Y2w5Y6f5aCG5qCI5L+h5oGvXG4gIGlmICghc291cmNlTGluaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaW5uZXJFcnJTdGFjayA9IGVyci5zdGFjay5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IFJFR19TVEFDS19JTk5FUl9NRVRIT0QgPSBpc0ZpcmVmb3hcbiAgICA/IC9eY2F0Y2hFcnJvcnNEZWNvcmF0b3JcXC88XFwvZGVzY3JpcHRvci52YWx1ZUAuKlxcZCQvXG4gICAgOiBuZXcgUmVnRXhwKGAke2NsYXNzTmFtZX1cXFxcLmRlc2NyaXB0b3IudmFsdWVcXFxccypcXFxcW2FzXFxcXHMke21ldGhvZE5hbWV9XFxcXF1cXFxccypcXFxcKC4qXFxcXCkkYCk7XG4gIGNvbnN0IFJFR19TVEFDS19JTk5FUl9NRVRIT0RfV0lUSE9VVF9MSU5LID0gaXNGaXJlZm94XG4gICAgPyAvXmNhdGNoRXJyb3JzRGVjb3JhdG9yXFwvPFxcL2Rlc2NyaXB0b3IudmFsdWUvXG4gICAgOiBuZXcgUmVnRXhwKGAke2NsYXNzTmFtZX1cXFxcLmRlc2NyaXB0b3IudmFsdWVcXFxccypcXFxcW2FzXFxcXHMke21ldGhvZE5hbWV9XFxcXF1gKTtcbiAgY29uc3QgaW5kZXhPZlNvdXJjZSA9IGlubmVyRXJyU3RhY2suZmluZEluZGV4KHN0ciA9PiBSRUdfU1RBQ0tfSU5ORVJfTUVUSE9ELnRlc3Qoc3RyKSk7XG4gIGxldCBpbm5lckVycjogRXJyb3I7XG4gIGlmIChpbmRleE9mU291cmNlICE9PSAtMSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCByZWFsRXJyU3RhY2sgPSBpbm5lckVyclN0YWNrLmZpbHRlcigodiwgaSkgPT4gaSA+IGluZGV4T2ZTb3VyY2UpO1xuICAgIHJlYWxFcnJTdGFjay51bnNoaWZ0KGlubmVyRXJyU3RhY2tbaW5kZXhPZlNvdXJjZV1cbiAgICAgIC5yZXBsYWNlKFJFR19TVEFDS19JTk5FUl9NRVRIT0RfV0lUSE9VVF9MSU5LLCBgJHtjbGFzc05hbWV9LiR7bWV0aG9kTmFtZX1gKVxuICAgICAgLnJlcGxhY2UoUkVHX1NUQUNLX0xJTkssIHNvdXJjZUxpbmspKTtcbiAgICBpbm5lckVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlubmVyRXJyLnN0YWNrID0gYCR7aXNGaXJlZm94ID8gJ0BkZWJ1Z2dlcicgOiAnRXJyb3InfVxcbiR7cmVhbEVyclN0YWNrLmpvaW4oJ1xcbicpfWA7XG4gIH1cbiAgcmV0dXJuIGlubmVyRXJyO1xufVxuIl19